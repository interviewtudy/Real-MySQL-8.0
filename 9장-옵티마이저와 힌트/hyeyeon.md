# 개요

쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며,
그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업을 DBMS의 옵티마이저가 담당한다.

옵티마이저가 만들어 내는 실행 계획 이해 하기

## 쿼리 실행 절차

1. 사용자 SQL 문장을 쪼개서 MYSQL 서버가 이해할 수 있는 수준으로 분리한다.
   - 해당 단계를 SQL 파싱이라고하고 SQL 파스 트리를 만들어낸다.
   - SQL 파서 모듈로 처리한다
   - 문장 오류도 해당 단계에서 확인한다
2. SQL의 파싱 정보를 확인하면서 읽을 테이블, 인덱스를 사용할지 선택한다.
   - 최적화 및 실행 계획 수립 단계 <- 옵티마이저에서 처리한다.
   - SQL 파스 트리를 참조해서 다음 작업을 한다.
     - 불필요한 조건 제거 및 복잡한 연산의 단순화
     - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
     - 가져온 레코드들을 임시 테이블에 넣고 재가공 여부를 결정
   - 실행 계획을 만들어 낸다.
3. 2에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다
   - MySQL 엔진에서 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

## 옵티마이저의 종류

1. 규칙 기반 최적화 방법
   - 옵티마이저에 내장된 우선 순위에 따라 실행 계획을 수립하는 방식
   - 통계 정보(테이블의 레코드 건수나 칼럼값의 분포도)를 조사하지 않기에 항상 같은 실행 방법을 만들어낸다 -> 최근에는 거의 사용되지 않음
2. 비용 기반 최적화 방법
   - 쿼리를 처리하기 위한 방법을 만들고 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획 별 비용을 산출한다.
   - 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 터리 방식을 선택해 최종적으로 쿼리를 실행한다.

# 기본 데이터 처리

데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다

## 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔 : 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업

옵티마이저는 다음 조건이 일치할 때 주로 풀 테이블 스캔을 한다.

- 테이블의 레코드의 건수가 작아 인덱스보다 효율적일때
- where절이나 on절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 옵티마이저가 판단한 조건 일치 레코드 건수가 과도하게 많은 경우

## 병렬 처리

innodb_parallel_read_threads라는 시스템 변수를 이용해 하나의 쿼리를 여러개의 스레드를 이용해서 처리할지 변경할 수 있다.
스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어든다.
하지만 병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 정착된 CPU의 코어 개수를 넘기면 오히려 성능이 떨어질 수 도 있다.

## ORDER BY 처리

### 정렬을 처리하는 방법

|              | 장점                                                                       | 단점                                                                                                            |
| ------------ | -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| 인덱스 이용  | INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 정렬되어있어 읽어올 때 빠르다 | INSERT, UPDATE, DELETE 작업 시 인덱스 추가 삭제 작업이 필요하므로 느리다.</br> 인덱스 때문에 디스크 공간이 필요 |
| Filesort이용 | 정렬할 레코드가 많지 않으면 메모리에서 처리되므로 빠르다                   | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.                    |

모든 정렬을 인덱스 이용하도록 튜닝하는 건 어렵

인덱스를 사용하지 못하는 경우

- 정렬 기준이 너무 많아서 모두 인덱스를 생성할 수 없을 때
- GROUP BY의 결과 또는 DISTINCT 같은 처리 결과를 정렬할 때
- UNION의 결과 같이 임시 테이블의 결과를 다시 정렬할 때
- 랜덤하게 결과 레코드를 가져올 때
  실행계획을 살펴보면 Extra 컬럼에 Using filesort 메시지가 포함되면 Filesrot를 사용한지 알 수 있다.

### 소트버퍼

MySQL에서 정렬을 수행하기 위해 만들어둔 메모리 공간이다.
최대 사용 가능한 소트 버퍼의 크기는 sort_buffer_size 변수로 설정할 수 있다.
만약 정렬해야 할 레코드 수가 소트버퍼 크기보다 크다면 소트버퍼에서 부분 정렬을 수행하고 디스크에 쓰고 다시 해당 버퍼만큼 읽어서 정렬을 수행하고 병합하고 하는 과정을 반복해야 한다.
소트 버퍼의 크기가 너무 작으면 디스크 읽기 쓰기가 빈번해 질 것이다.
소트 버퍼의 크기가 너무 크면 동시 접속이 잦은 환경에서 운영체제는 메모리 부족 현상을 겪을 수 있다.
운영체제의 OOM-Killer는 메모리가 부족하면 메모리를 가장 많이 사용하는 프로세스를 강제로 종료할 것이다.

### 정렬 알고리즘

레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담아서 정렬할지, 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 싱글 패스와 투 패스 정렬로 나눌 수 있다.
쿼리가 어떤 정렬 모드를 수행하는지는 다음과 같이 옵티마이저 트레이스 기능으로 확인할 수 있다.

정렬 모드는 3가지로 나뉘어진다.
<sort_key, row_id> : 정렬 키와 레코드의 로우 아이디만 가져와서 정렬한다.
<sort_key, additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬한다. 레코드 칼럼은 고정 사이즈로 메모리에 저장한다.
<sort_key, packed_additional_fields> : 정렬 키와 레코드 전체를 가져와서 정려한다. 레코드 칼럼은 가변 사이즈로 메모리에 저장한다.
첫 번째 방식은 투 패스 정렬방식이고 나머지 두 방식은 싱글 패스 방식이다.

#### 싱글 패스 정렬방식

정렬에 필요하지 않은 칼럼까지 소트 버퍼에 담아서 정렬을 수행한다.

#### 투 패스 정렬방식

정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행한다.
정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져온다.
차이점
투패스 정렬방식은 테이블을 두 번 읽어야 하므로 상당히 비용이 많이 든다.
싱글 패스는 한 번만 읽어도 된다. 하지만 소트 버퍼의 공간을 많이 사용한다.
최근에는 일반적으로 싱글 패스를 많이 쓰지만 다음의 경우 투 패스 정렬방식을 사용한다.
레코드의 크기가 max_length_for_sort_data 값보다 클 때
BLOB, TEXT 타입의 칼럼이 SELECT 대상에 포함 될 때

### 정렬 처리 방법

쿼리에 ORDER BY 문이 포함되면 다음의 세 가지 방법 중 하나로 처리된다.
인덱스를 이용한 정렬 : 실행 계획의 Extra 컬럼 => 별도 표기 없음
조인의 드라이빙 테이블만 정렬 => Using filesort
조인 결과를 임시 테이블에 저장 후 정렬 => Using temporary; Using filesort
옵티마이저는 먼저 인덱스를 이용해서 정렬을 할 수 있을지 여부를 체크한다. 인덱스를 사용할 수 있으면 인덱스를 사용하고 그렇지 않으면 레코드를 정렬버퍼에 넣고 정렬을 수행한다. 이 때 MySQL 서버는 정렬 대상 레코드를 최소화하기 위해 다음 두 가지 방법 중 하나를 수행한다.

조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
조인이 끝나고 결과 레코드 모두를 가져와서 정렬을 수행

#### 인덱스를 이용한 정렬

조건
인덱스를 이용하려면 먼저 ORDER BY 에 명시된 컬럼이 제일 먼저 읽는 테이블(조인을 한다면)에 속해야 한다.
또한, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
인덱스를 이용한 정렬은 이미 인덱스 자체가 정렬돼 있기 때문에 순서대로 읽기만 하면 된다. (추가 작업이 없음)
조인을 하더라도 네스티드 루프 방식으로 실행되기 때문에 조인으로 인해 순서가 흐트러지지 않는다.

#### 조인의 드라이빙 테이블만 정렬

조건
인덱스를 이용하려면 먼저 ORDER BY 에 명시된 컬럼이 제일 먼저 읽는 테이블(조인을 한다면)에 속해야 한다.
일반적으로 조인이 수행되고 나면 레코드 수가 꽤나 증가한다. 따라서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이다.

#### 임시 테이블을 이용한 정렬

하나의 테이블만을 정렬하거나 9.2.3.3.2와 같이 2개 이상의 테이블을 조인하더라도 드라이빙 테이블만 정렬하여 처리할 수 있는 경우는 임시 테이블이 필요하지 않다.
하지만 그 외 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고 그 결과를 다시 정렬하는 과정을 거친다.
이 방법은 가장 느린 정렬 방법이다.

쿼리의 실행 계획을 보면 Extra 칼럼에 Using temporary; Using filesort라는 코멘트가 남는다.
이는 임시 테이블에 조인 결과를 저장하고 그 결과를 정렬했다는 의미이다.

#### 정렬 처리 방법의 성능 비교

일반적으로 limit은 처리하는 양을 줄일 수 있기 때문에 서버가 처리할 작업량을 줄일 수 있다고 생각한다. 하지만 데이터를 처리하는 방식에 따라 limit으로 처리량이 줄 수도있고 줄지 않을 수도 있다. 다음 두 가지 방식을 살펴보자.

스트리밍 방식 : 서버 쪽에서 레코드가 검색될 때마다 바로바로 클라이언트로 결과를 전송해주는 방식이다. 이 방식에서는 limit 제한을 걸면 처리량을 줄이고 마지막 레코드를 가져오는 시간을 줄일 수 있다.
버퍼링 방식 : 데이터를 스캔할 때 order by나 group by를 걸면 스트리밍이 불가능하다. where 조건에 만족하는 모든 레코드를 가져와서 정렬하거나 그루핑해서 차례로 응답을 보내야한다. 즉 결과를 모아서 일괄 가공해야 하므로 limit과 같은 결과 건수를 제한하는 조건은 성능 향상에 도움이 되지 않는다.
order by 처리방식 중에서 인덱스를 이용한 정렬 방식만 스트리밍 형태의 처리이고 나머지는 모두 버퍼링 방식이다.

## GROUP BY 처리

group by는 order by와 비슷하게 스트리밍 방식의 데이터 처리를 사용할 수 없게 만든다.
group by 작업은 다음과 같이 나눌 수 있다.
인덱스 이용
인덱스 스캔 : 인덱스를 차례로 읽는 방식
루스 인덱스 스캔 : 인덱스를 건너뛰면서 읽는 방식
인덱스를 이용 x : 임시 테이블 사용

### 인덱스 스캔을 이용하는 Group By(타이트 인덱스 스캔)

조건
조인의 드라이빙 테이블에 속한 칼럼만을 이용해 그루핑
group by의 순서로 인덱스가 있어야 함

### 루스 인덱스 스캔을 이용하는 Group by

인덱스 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 방식
루스 인덱스 스캔이 되는 지 조건을 판별하기가 어렵다.

### 임시 테이블을 사용하는 Group By

인덱스를 전혀 사용하지 못할 때에는 임시테이블을 만든다.
group by 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 합수 연산을 수행한다.

## DISTINCT 처리

특정 컬럼의 유니크한 값만 조회하기 위해 SELECT 쿼리에 DISTINCT를 사용한다.

SELECT DISTINCT
GROUP BY와 동일한 방식으로 처리된다. 참고로 SELECT절의 DISTINCT는 SELECT절의 모든 컬럼들을 기준으로 유니크한 값들을 가져온다.

SELECT DISTINCT first_name, last_name FROM employees;
즉, 위 쿼리는 성이 같지만 이름이 다른 경우를 유니크한 값으로 판단하여 결과에 포함한다.
집합 함수와 함께 사용된 DISTINCT

SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100;
이 쿼리는 COUNT(DISRINCT s.salary)를 처리하기 위해 임시 테이블을 사용한다. 이때 임시 테이블의 salary 컬럼엔 유니크 인덱스가 생성되기 때문에 레코드 수가 많아지면 느릴 수 있다. 하지만 인덱스된 컬럼에 대해 DISTINCT 처리를 할 땐 인덱스를 이용하며 임시 테이블 없이 처리할 수 있다.

## 내부 임시 테이블 활용

MySQL 엔진이 스토리지 엔진으로부터 받은 레코드를 정렬, 그루핑할 때는 내부적인 임시 테이블을 사용한다.
이는 CREATE TEMPORARY TABLE 명령으로 만든 임시 테이블과는 다르다.
내부 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제된다.

### 메모리 임시 테이블과 디스크 임시 테이블

시스템 변수를 이용해 임시 테이블이 최대로 사용 가능한 메모리 공간의 크기를 정할 수 있다. 메모리에 저장되는 임시 테이블은 TempTable을, 디스크에 저장되는 임시 테이블은 InnoDB를 사용한다.

### 임시 테이블이 필요한 쿼리

어떤 쿼리에서 임시테이블을 사용하는지는 Extra 컬럼의 Using temporary 가 표시되는지 확인하면 된다. 대표적으로 아래와 같은 경우에 내부 임시 테이블을 생성한다.
ORDER BY와 GROUP BY에 명시된 컬럼이 다른 쿼리
ORDER BY와 GROUP BY에 명시된 컬럼이 드라이빙 테이블이 아닌 쿼리
DISTINCT와 ORDER BY가 동시에 존재하거나 DISTINCT가 인덱스로 처리되지 못하는 쿼리
UNION이나 UNION DISTINCT가 사용된 쿼리
쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리
위 경우 중 마지막 쿼리 패턴을 제외하고 전부 유니크 인덱스를 가지는 내부 임시 테이블이 만들어진다.
일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 처리 성능이 느린편이다.

# 고급 최적화

옵티마이저는 최적의 실행 계획을 수립하기 위해 통계 정보와 옵티마이저 옵션을 결합하여 이용한다.

옵티마이저 옵션은 크게 조인 관련 옵티마이저 옵션과 옵티마이저 스위치로 구분된다.

## 옵티마이저 스위치 옵션

옵티마이저 스위치 옵션은 optimizer_switch 시스템 변수를 이용하여 제어하는데, 여러 옵션을 세트로 묶어 설정하는 방식으로 사용한다.

옵티마이저 스위치 옵션은 optimizer_switch 시스템 변수를 이용하여 제어

네스티드 루프 조인 (Nested Loop Join)
가장 자주 사용되는 조인 방식이고, 이 방식은 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아 조인을 수행하는 방식이다. 아래와 같은 쿼리로 예시를 들어보자.
SELECT \*
FROM employees e
INNER JOIN salaries s
ON s.emp_no=e.emp_no;
위 쿼리는 employees 테이블이 드라이빙 테이블이 되어 순서대로 레코드를 한 건 읽고, 드리븐 테이블인 salaries 에서 조건에 만족하는 레코드를 찾아서 바로 반환한다. 이를 의사 코드로 표현하면 아래와 같다.
for(row1 IN employees) {
for(row2 IN salaries) {
if(row1.emp_no == row2.emp_no) return (row1, row2);
}
}
위 코드에서 알 수 있듯이 레코드를 읽어서 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아 반환한다.

### MRR과 배치 키 엑세스 (mrr & batched_key_access)

MySQL 서버에서 지원하던 조인 방식은 Nested Loop Join 방식인데 이 방식으로 레코드를 읽고 바로 조인을 하면 스토리지 엔진에서는 아무런 최적화를 할 수 없다. 이를 보완하기 위해 MySQL에서는 레코드를 읽고 바로 조인을 하지 않고 조인 버퍼에 버퍼링하고, 버퍼에 레코드가 가득 차면 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다. 이 과정에서 레코드를 읽을 때 디스크 및 버퍼 풀 접근을 최소화하여 성능을 향상시킬 수 있다. 이러한 읽기 방식을 MRR(Multi Range Read)라고 하며, MRR을 응용한 조인 방식을 BKA 조인이라 한다. BKA 조인은 쿼리에 따라 큰 도움이 되는 경우도 있지만, 부가적인 정렬로 인해 성능에 악영향을 미칠 수 있다.

### 블록 네스티드 루프 조인 (block_nested_loop)

네스티드 루프 조인과의 가장 큰 차이는 조인 버퍼 사용 여부와 테이블이 어떤 순서로 조인되느냐이다. 조인 알고리즘에서 “Block”이라는 단어가 사용되면 조인용으로 버퍼가 사용됐다는 것을 의미한다. 만약 드리븐 테이블의 레코드를 찾을 때 인덱스를 사용할 수 없다면 드라이빙 테이블의 레코드 수 만큼 드리븐 테이블을 풀 스캔하게된다. 만약 어떤 방식으로도 위 상황을 피할 수 없다면 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 뒤 드리븐 테이블과 메모리 캐시를 조인하는 형태로 처리한다. 이 때 사용되는 메모리의 캐시를 조인 버퍼라고 한다. 결국 블록 네스티드 루프 조인 방식은 조인 버퍼를 이용하여 조인을 하는데, 이 때 드라이빙 테이블의 결과를 조인 버퍼에 담아두고 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다. 주의할 점은 일반적으로 조인이 수행된 후 가져오는 결과는 드라이빙 테이블의 순서에 의해 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 달라질 수 있다는 것이다.

### 인덱스 컨디션 푸시다운 (index_condition_pushdown)

인덱스 컨디션 푸시 다운은 WHERE 절의 조건 중 일부를 스토리지 엔진 레벨에서 평가하도록 "푸시 다운"하여, 필요하지 않은 레코드를 더 빠르게 걸러내는데 도움을 준다.
장점

- 효율적인 레코드 필터링이 가능하다.
- 불필요한 레코드를 걸러내기 위한 작업이 줄어들어 CPU 사용이 줄어든다.</br>

단점

- 특정 쿼리나 데이터셋에서는 성능 저하의 원인이 될 수 있다.
- InnoDB, MEMORY 스토리지 엔진에서만 사용된다.

→ 대부분의 경우에선 활성화 하는 것이 좋다.

### 인덱스 확장 (useindex_extensions)

use_index_extensions 옵션은 세컨더리 인덱스에 추가된 PK를 활용여부를 결정하는 옵션이다.

### 인덱스 머지 (index_merge)

인덱스 머지는 하나의 테이블에 2개 이상의 인덱스를 이용해서 나온 결과를 병합하는 방식으로 처리된다.

### 인덱스 머지 - 교집합 (index_merge_intersection)

교집합의 경우는 2개 이상의 인덱스를 이용해서 나온 여러 결과들을 AND 연산자로 연결할 경우 실행된다. 실행 계획의 Extra 컬럼에 Using intersect(idx_1, PRIMARY) 라는 메시지가 있다면 idx_1와 PK로 검색한 두 결과를 교집합했다는 뜻이다. 만약 1개의 인덱스를 사용하는 것이 더 효율적이면 index_merge_intersection 최적화를 비활성화 하자.

### 인덱스 머지 - 합집합 (index_merge_union)

합집합의 경우는 2개 이상의 인덱스를 이용해서 나온 여러 결과들을 OR 연산자로 연결할 경우 실행된다.
// idx_1(first_name), idx_2(hire_date) 두 세컨더리 인덱스가 생성되어 있다.
SELECT * FROM employees WHERE first*name='Matt' OR hire_date='1987-03-31';
위와 같은 쿼리의 실행 계획에 Using union(idx_1, idx_2 이러한 메시지가 나왔다면 두 인덱스로 검색한 값을 합집합 했다는 것이다. 이때, 합집합 연산을 진행하며 중복되는 데이터가 있을 수 있는데, first_name='Matt'인 레코드와 hire_date='1987-03-31'인 레코드는 인덱스 스캔을 하게되면 PK로 정렬되어 있으므로 두 결과를 우선 순위 큐 알고리즘을 통해 합치면서 중복을 제거한다.
참고 1
모든 세컨더리 인덱스는 클러스터링 인덱스인 PK를 포함하고 있으므로 같은 값 끼리는 PK로 정렬된다.
참고 2
두 조건이 AND로 연결된 경우에는 두 조건 중 하나라도 인덱스를 사용할 수 있으면 인덱스 레인지 스캔으로 쿼리가 실행되지만 OR로 연결된 경우에는 둘 중 하나라도 인덱스를 사용하지 못하면 풀 테이블 스캔으로 처리된다.

### 인덱스 머지 - 정렬 후 합집합 (index_merge_sort_union)

만약 별도의 정렬이 필요한 경우에는 “Sort union”알고리즘을 사용한다. 이전 예제처럼 동등 조건을 사용하면 정렬이 필요 없지만, BETWEEN 같은 경우는 정렬이 필요하다. 이렇게 합집합 연산 전에 정렬을 해야하는 경우 Extra 컬럼에 Using sort_union 문구가 표시된다.

### 세미 조인 (semijoin)

실제 조인을 수행하진 않고 다른 테이블에 조건에 맞는 레코드가 있는지 체크하는 쿼리를 세미 조인이라 한다. 일단 세미조인 최적화 옵션은 ON으로 해놓자. 아래 쿼리가 세미 조인의 대표적인 예시이다.
SELECT *
FROM employees e
WHERE e.emp*no IN
(SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1995-01-01');

### 테이블 풀 아웃 (Table Pull-out)

테이블 풀 아웃 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태이다.

SELECT *
FROM employees e
WHERE e.emp*no IN
(SELECT de.emp_no FROM dept_emp de WHERE de.dept_no='d009');
위 쿼리에 테이블 풀 아웃 최적화를 적용하면 아래와 같은 쿼리로 바뀐다.

SELECT e.*
FROM dept*emp de
JOIN employees e
WHERE e.emp_no=de.emp_no AND de.dept_no='d009';
즉, 기존 서브쿼리를 조인으로 풀어서 사용한 형태이다. 테이블 풀 아웃 최적화는 서브쿼리 부분에서 유니크 인덱스나 PK로 검색하여 결과가 1건인 경우에만 사용가능하다. 또한, 테이블 풀 아웃은 다른 최적화와 함께 적용될 수 있으므로 가능하면 최대한 적용한다.

### 퍼스트 매치 (firstmatch)

퍼스트 매치 최적화는 IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행된다.
SELECT *
FROM employees e
WHERE e.first*name='Matt'
AND e.emp_no IN (
SELECT t.emp_no FROM titles t
WHERE t.from_date BETWEEN '1995-01-01' AND '1995-01-30'
);
위 쿼리는 first_name='Matt'인 레코드들을 찾고 그 결과와 titles 테이블을 조인하는 식으로 실행된다. 조인하는 과정에서 e.emp_no가 1이고, e.first_name이 ‘Matt’인 레코드와 e.emp_no가 3이고, e.first_name이 ‘Matt’인 레코드를 찾은 상태라고 하자. t.emp_no가 1인 레코드들 중 t.from_date BETWEEN '1995-01-01' AND '1995-01-30' 인 레코드를 하나만 발견하면 더이상 emp_no가 1인 경우에 대해서는 탐색하지 않는다. 그런 뒤 emp_no가 2인 레코드에 대해서도 동일한 작업을 시행한다.

### 루스 스캔 (loosescan)

세미 조인 서브쿼리 최적화의 루스 스캔은 GROUP BY의 루스 인덱스 스캔과 비슷한 방식을 사용한다.
// departments 테이블의 레코드는 9건, dept_emp 테이블의 레코드는 33만건
SELECT
FROM departments d
WHERE d.dept_no IN (
SELECT de.dept_no FROM dept_emp de);
위 쿼리는 dept_emp 테이블에 존재하는 모든 부서 번호에 대해 부서 정보를 읽어 오는 쿼리다. dept_emp 테이블은 dept_no를 기준으로 그루핑하면 9건 밖에 없다. → dept_emp 테이블을 루스 인덱스 스캔으로 유니크한 dept_no만 읽으면 효율적 실행이 가능하다.

### 구체화 (materialization)

Materialization 최적화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화하는 방식이다. 구체화는 쉽게 표현하면 내부 임시 테이블을 생성한다는 것을 의미한다. 보통 FirstMatch 최적화가 도움이 안되는 경우에 사용된다. 서브 쿼리의 결과로 임시 테이블을 만들고, 임시 테이블과 대상 테이블을 조인해서 결과를 반환하는 식이다. Materialization 최적화는 서브쿼리가 코릴레이트 서브쿼리가 아니여야 사용가능하고, GROUP BY나 집합 함수가 사용되어도 사용 가능하다.

### 중복 제거 (Duplicated Weed-out)

Duplicate Weedout은 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다. 보통 이 방법으로 최적화되는 경우는 다른 최적화 방법이 많이 있다.

### 컨디션 팬아웃 (condition_fanout_filter)

condition_fanout_filter 최적화를 활성화하면 옵티마이저가 조건을 충족하는 레코드 수를 더 정확히 예측할 수 있다. 조인 시 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미치는데, 예상 레코드 수가 정확해 지면 옵티마이저가 더 효율적인 순서로 조인이 실행되도록 계획을 세울 수 있다. 대신 condition_fanout_filter 최적화를 활성화하면 계산을 위해 더 많은 자원을 사용한다. 그러므로 쿼리의 실행 계획이 잘못된적이 별로 없다면 별로 도움이 되지 않는다.

### 파생 테이블 머지 (derived_merge)

이전 버전 MySQL에선 FROM절에 사용된 서브쿼리는 먼저 실행해서 임시 테이블로 만드는 식으로 처리했다. 이 실행 계획은 임시 테이블을 생성하고 조건에 맞는 레코드를 읽어서 임시 테이블에 INSERT한다. 그리고 다시 임시 테이블을 읽으므로 오버헤드가 추가된다. 만약 임시 테이블의 크기가 메모리에 못 들어갈 정도로 커지면 성능은 많이 느려질 것이다. derived_merge최적화 옵션은 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합하는 식으로 최적화한다.

### 인비저블 인덱스 (use_invisible_indexes)

인덱스를 삭제하지 않으면서 옵티마이저가 사용하지 못하도록 할 수 있다. use_invisible_indexes 옵티마이저 옵션을 이용하면 INVISIBLE로 설정된 인덱스도 사용할 수 있다.

### 스킵 스캔 (skip_scan)

인덱스 스킵 스캔은 인덱스의 선행 컬럼이 아닌 컬럼을 조건으로 쓸 때 사용할 수 있는 최적화 방법이다. 만약 인덱스 선행 컬럼의 카디널리티가 크면 스킵 스캔최적화를 비활성화 하는 것이 좋다.

### 해시 조인 (hash_join)

image해시 조인은 첫 레코드를 찾는데는 오래걸리지만, 마지막 레코드를 찾는 시점은 더 빠르다. 즉, 중첩 루프 조인은 첫 레코드는 빠르게 받기 때문에 최고 응답 속도 전략(OLTP에 유리)에 적합하고, 해시 조인은 최고 스루풋 전략(OLAP에 유리)에 적합하다. 해시 조인은 두 단계로 나뉘어 처리된다.
빌드 단계: 조인 대상 테이블 중 레코드 건수가 적은 테이블을 메모리에 해시 테이블을 생성한다.
프로브 단계: 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는다.
보통 네스티드 루프 조인을 사용할 수 없는 경우 해시 조인이 사용된다.

### 인덱스 정렬 선호 (prefer_ordering_index)

SELECT
FROM employees
WHERE hire_date BETWEEN '1985-01-01' AND '1985-02-01'
ORDER BY emp_no;
위 쿼리는 대표적으로 아래 2가지 실행 계획을 선택할 수 있다.
hire_date 컬럼으로 생성된 인덱스를 이용해 조건에 맞는 레코드를 찾고 emp_no로 정렬
PK를 정순으로 읽으며 조건에 맞는 레코드를 찾아서 반환
일반적으로는 hire_date 컬럼의 조건에 부합되는 레코드 건수가 많지 않다면 1번이 효율적일 것이다.
하지만, 옵티마이저가 ORDER BY절의 인덱스에 가중치를 너무 부여하여 2번이 선택될 수 있다.
이렇게 자주 실수를 한다면 prefer_ordering_index 옵션을 OFF로 변경하자.

### 조인 최적화 알고리즘

Exhaustive 검색 알고리즘, Greedy 검색 알고리즘 두 가지가 있다.
조인 테이블 개수가 많아지면 실행 계획을 수립하는 데만 많은 시간이 걸린다.

# 쿼리 힌트

MySQL에서 사용 가능한 쿼리 힌트는 인덱스 힌트, 옵티마이저 힌트 두 가지로 구분할 수 있다.

쿼리 힌트는 옵티마이저에게 올바른 방향으로 실행 계획을 수립할 수 있도록 알려주는 역할을 한다.

## 인덱스 힌트

인덱스 힌트는 SELECT, UPDATE 문에서만 사용할 수 있고, 가능하면 옵티마이저 힌트를 사용할 것을 추천한다.

### STRAIGHT_JOIN

STRAIGHT_JOIN은 SELECT STRAIGHT_JOIN ~ 이러한 형태로 쓰이고, FROM절에 명시된 테이블의 순서대로 조인을 수행하도록 유도한다.
USE / FORCE / IGNORE INDEX

SELECT
FROM table_1 USE INDEX [FOR ORDER BY/GROUP BY/JOIN](idx_1)

~ INDEX 힌트를 사용하기 위해선 위 쿼리와 같이 인덱스를 가지는 테이블 뒤에 힌트를 명시해야한다. FOR ORDER BY/GROUP BY/JOIN 를 붙혀 인덱스의 용도를 제한할 수 있다. USE는 인덱스 사용 권장, FORCE는 더 강하게 사용 권장(잘 안씀), IGNORE는 인덱스를 못 사용하게 한다.

### SQL_CALC_FOUND_ROWS

LIMIT이 걸려있어도 끝까지 검색하여 결과를 반환하도록 하는 힌트이다.

## 옵티마이저 힌트

옵티마이저 힌트는 영향 범위에 따라 4가지로 나눌 수 있다.

인덱스: 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
테이블: 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
쿼리 블록: 힌트가 명시된 쿼리 블록에 대해서 영향을 미치는 옵티마이저 힌트
글로벌(쿼리 전체): 전체 쿼리에 대해서 영향을 미치는 힌트
참고로 모든 인덱스 수준의 힌트는 아래와 같이 테이블명이 선행되어야 한다.

SELECT INDEX(employees ix_firstname)
FROM employees
WHERE first\*name='Matt';

### MAX_EXECUTION_TIME

쿼리의 최대 실행 시간을 설정하는 힌트다. 밀리초 단위의 시간을 설정할 수 있으며, 지정된 시간을 초과하면 쿼리가 실패한다.
SET_VAR
MySQL 서버의 시스템 변수를 설정하는 힌트이다.

### SEMIJOIN & NO_SEMIJOIN

SEMIJOIN(세미조인최적화전략이름) 힌트는 어떤 세미 조인 최적화 전략을 사용할지를 제어할 수 있다. 만약 세미 조인을 사용하고 싶지 않다면 NO_SEMIJOIN 힌트를 사용하면된다.
SUBQUERY
서브쿼리 최적화는 세미 조인 최적화가 사용되지 못할 때 사용하는 방법으로 INTOEXISTS와 MATERIALIZATION 두 가지 방법이 있다.

### BNL & NO_BNL & HASHJOIN & NO_HASHJOIN

해시 조인을 유도하고 싶으면 BNL(테이블1, 테이블2) 이렇게 힌트를 작성하고, 사용하지 않게 한다면 NO_BNL 힌트를 사용하면 된다.
JOIN 관련
JOIN 순서를 위한 4가지 힌트가 있다.
JOIN_FIXED_ORDER(): FROM절의 테이블 순서대로 조인을 실행
JOIN_ORDER(tb1,tb2, ...): 힌트에 명시된 테이블 순서대로 조인을 실행
JOIN_PREFIX(tb1): 드라이빙 테이블을 설정
JOIN_SUFFIX(tb1, tb2, …): 드리븐 테이블을 설정

### MERGE & NO_MERGE

MERGE(서브쿼리이름): 임시 테이블을 사용하지 않게 서브 쿼리를 외부 쿼리와 병합 NOMERGE(서브쿼리 이름): 임시 테이블을 사용하도록 강제

### INDEX_MERGE & NO_INDEX_MERGE

인덱스 머지를 강제하거나 사용하지 않도록 하는 힌트이다.

### NO_ICP

인덱스 컨디션 푸시다운 최적화는 성능 향상에 도움이 되므로 사용하는 방향으로 실행 계획을 수립한다. 그런데 ICP로 인해 실행 계획 비용 계산이 잘못되어 잘못된 실행 계획이 수립될 수도 있다. 그래서 NO_ICP 힌트로 ICP를 비활성화할 수 있다.

### SKIP_SCAN & NO_SKIP_SCAN

인덱스 스킵 스캔을 강제하거나 사용하지 않도록 하는 힌트이다.

### INDEX & NO_INDEX

이전에 사용되던 인덱스 힌트를 대체하는 용도로 제공되는 힌트이다.
