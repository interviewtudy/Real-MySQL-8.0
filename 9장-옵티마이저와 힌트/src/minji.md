# 개요

옵티마이저는 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼있는지 통계 정보를 참조하며, 기본 데이터를 비교해 최적의 실행 계획을 수립함

## 쿼리 실행 절차

1. SQL 파싱(Parsing)<br/>
   사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리하는 과정. SQL 파서라는 모듈로 처리하며 SQL 문장이 잘못됐다면 이 단계에서 걸러짐. 이 단계에서 SQL 파스 트리가 만들어짐
2. 최적화 및 계획 수립 - 옵티마이저에서 처리 <br/>
   SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택함. 불필요한 조건 제거 및 복잡한 연산의 단순화, 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정, 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정, 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정 등 수많은 처리를 진행함
3. 스토리지 엔진으로부터 데이터 가져오기 <br/>
   두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져오는 과정. MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행함

<br/><br/>

## 옵티마이저의 종류

- 비용 기반 최적화(Cost-based optimizer, CBO)
  - 현재 대부분의 DBMS가 선택하고 있는 방법
  - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
  - 산출된 실행 방법별로 최소 비용의 처리 방식을 선택하여 쿼리를 실행함
- 규칙 기반 최적화(Rule-based optimizer, RBO)
  - 예전 초기 버전의 오라클 DBMS에서 많이 사용했던 방법
  - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행계획을 수립
  - 통계 정보(테이블의 레코드 건수, 칼럼값의 분포도 등)를 조사하지 않고 실행계획이 수립되기 때문에 같은 쿼리는 거의 항상 같은 실행 방법을 만들어냄
  - 기존에 각 테이블이나 인덱스의 통계 정보가 거의 없고 상대적으로 느린 CPU 연산 탓에 비용 계산 과정이 부담스러워 사용되던 방법으로 현재는 거의 안쓰임

<br/><br/>

# 기본 데이터 처리

모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등 기본 데이터 가공 기능을 가지고 있고, RDBMS별로 그 결과를 만들어 내는 과정이 천차만별임

## 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업
- 다음 조건이 일치할 때 풀 테이블 스캔을 선택함
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠를 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스와 B-Tree를 샘플링해서 조사한 통계 정보 기준)
- 대부분의 DBMS는 풀 테이블 스캔시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있지만 MySQL은 없음
  - MyISAM 스토리지 엔진에서는 디스크로부터 페이지를 하나씩 읽어옴
  - InnoDB 에서는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업(어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 시작되기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것)이 자동으로 시작됨
    - 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지를읽지만 특정 시점부터는 백그라운드 스레드로 읽기 작업이 넘어감
    - 백그라운드 스레드로 읽기 작업이 넘어가는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시키고 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장함
    - `innodb_read_ahead_threshold` 시스템 변수를 이용해 리드 어헤드 시작 시점 임계값을 설정할 수 있음
    - 풀 테이블 스캔 뿐 아니라 풀 인덱스 스캔에서도 동일하게 사용됨

<br/><br/>

## 병렬 처리

- MySQL 8.0 버전부터는 한정된 용도지만 처음으로 쿼리의 병럴 처리가 가능해짐(하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것)
- `innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇개의 스레드를 이용해서 처리할지 변경할 수 있음
- 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능함

<br/><br/>

## ORDER BY 처리(Using filesort)

- 데이터 정렬을 처리하는 방법
  - 인덱스 이용
    - 장점: INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름
    - 단점: INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요해 느림. 인덱스 때문에 디스크 공간이 더 많이 필요함. 인덱스의 개수가 늘어날수록 innoDB의 버퍼 풀을 위한 메모리가 많이 필요함
  - Filesort 이용
    - 장점: 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀜. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름
    - 단점: 정렬 작업이 쿼리 실행 시 실행되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느림
- 레코드 정렬을 위해 항상 Filesort 정렬 작업이 필요한 것은 아니지만 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능하거나 랜덤하게 결과 레코드를 가져와야 하는 등 모든 정렬을 인덱스를 이용하도록 튜닝하는 것은 거의 불가능함
- 실행 계획의 Extra 칼럼에 Using filesort 메시지가 표시되는지 여부로 판단할 수 있음

<br/><br/>

## 소트 버퍼

- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데 이 메모리 공간을 소트 버퍼라고 함
- 정렬이 필요한 경우에만 할당되고 버퍼의 크기는 정렬해야할 레코드의 크기에 따라 가변적으로 증가함
- 최대 사용 가능한 소트 버퍼의 공간은 `sort_buffer_size` 시슽메 변수로 설정 가능
- 소트 버퍼를 위한 메모리 공간은 쿼리 실행 완료 즉시 시스템으로 반납됨
- 레코드 건수가 소트 버퍼로 할당된 공간보다 크다면 레코드를 여러 조각으로 나눠서 처리하고 이 과정에서 임시 저장을 위해 디스크를 사용함 -> 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행하는, 멀티 머지가 진행됨
- 멀티 머지 횟수는 `Sort_merge_passes`라는 상태 변수에 누적해서 집계됨
- 소트 버퍼를 크게 설정한다고 무조건 빨라지지 않고 리눅스 계열의 운영체제에선 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있음
- 대량 데이터의 정렬이 필요한 경우 해당 세션의 소트 버퍼만 일시적으로 늘려서 쿼리를 실행하고 다시 줄이는 방법을 선택할 수 있음

### 정렬 알고리즘

- 정렬 모드 2가지
  - 싱글 패스: 레코드 전체를 소트 버퍼에 담음. 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨줌. 일반적으로는 싱글 패스 정렬 방식을 주로 이용하지만 항상 사용하는 것은 아님
  - 투 패스: 정렬 기준 칼럼만 소트 버퍼에 담음. 테이블을 두 번 읽어야 하는 것은 단점이지만 싱글 패스는 더 많은 소트 버퍼 공간을 필요로 함
- 정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능을 이용해 filesort_summary 섹션을 보면 알 수 있음
- 정렬 방식 3가지
  - <sort_key, rowid>: 정렬 키와 레코드의 로우 아이디만 가져와서 정렬(투 패스)
  - <sort_key, additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈로 메모리 저장(싱글 패스)
  - <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 가변 사이즈로 메모리 저장(싱글 패스). MySQL 5.7 버전부터 메모리 공간의 효율적 사용을 위해 추가 도입됨

### 정렬 처리 방법

#### 인덱스를 이용한 정렬

- 다음 조건을 만족해야 사용할 수 있음
  - ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속해야 함
  - ORDER BY 순서대로 생성된 인덱스가 있어야 함
  - WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 같은 ORDER BY는 같은 인덱스를 사용할 수 있어야 함
  - B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스에선 사용 불가(R-Tree도 사용 불가)
  - 조인이 사용되는 경우 네스티드-루프 방식의 조인에서만 이용할 수 있음
- 인덱스를 이용해 정렬이 처리되는 경우, 실제 인덱스 값이 정렬돼 있기 때문에 별도의 정렬을 위한 추가 작업 없이 인덱스의 순서대로 읽음
- 조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수 있으므로 주의해야 함
- ORDER BY 절을 넣지 않아도 자동 정렬되므로 ORDER BY 문을 제거한다고 해서 작업량이 늘지 않고, 명시하지 않았을 때 오히려 오류가 발생할 수 있으므로 명시하는 것이 좋음

#### 조인의 드라이빙 테이블만 정렬

- 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 경우 조인을 실행하는 것
- 드라이빙 테이블의 칼럼만으로 ORDER BY 절을 작성해야만 사용 가능
- 조인의 드라이빙 테이블만 정렬하는 경우는 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 이용하지 않음

#### 임시 테이블을 이용한 정렬

- 2개 이상의 테이블을 조인 할 때 조인의 드라이빙 테이블만 정렬하는 패턴을 제외하고는 조인 결과를 임시 테이블에 저장하고, 임시 테이블을 정렬하는 과정을 거침
- 세 가지 방법 중 가장 정렬해야할 레코드 건수가 많기 때문에 가장 느림

#### 정렬 처리 방법의 성능 비교

- LIMIT은 테이블이나 처리 결과의 일부만 가져오기 때문에 작업량을 줄이는 역할을 하지만 ORDER B나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서 처리할 수 없음
- 쿼리 처리 방법 2가지
  - 스트리밍 방식: 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식. 첫 번째 레코드를 찾자마자 전송하므로 응답 시간을 줄일 수 있고 LIMIT 조건이 실행 시간을 상당히 단축시킬 수 있음. 인덱스를 이용한 정렬 방식이 해당
  - 버퍼링 방식: ORDER BY, GROUP BY 같이 전체 정렬 작업을 클라이언트가 기다려야 하는 방식. 조인의 드라이빙 테이블만 정렬하는 방식과 임시 테이블을 이용한 정렬 방식이 해당
- 어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만들어냄

### 정렬 관련 상태 변수

- MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장함
- 멀티 머지 처리 횟수, 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수 등이 해당

<br/><br/>

## GROUP BY 처리

- HAVING 절은 GROUP BY 결과에 대해 필터링 역할을 수행
- GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없음 -> HAVING 절은 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요가 없음

### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

- GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리
- GROUP BY가 인덱스를 사용해서 처리된다 하더라도 그룹 함수 등의 그룹값을 처리해야해서 임시 테이블이 필요할 수 있는데, 이는 정렬 작업과 무관하게 그룹 함수를 처리하기 위함이므로 쿼리의 실행 계획에선 별도로 언급이 없을 수 있음

### 루스 인덱스 스캔을 이용하는 GROUP BY

- 루스 인덱스 스캔: 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
