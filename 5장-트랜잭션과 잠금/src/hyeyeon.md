MYSQL의 동시성에 영향을 미치는 잠금과 트랜잭션의 격리 수준

- 트랜잭션 : 데이터의 정합성을 보장하기 위한 기능

  - 작업의 완전성을 보장해주는 것.
  - 즉 논리적인 작업 셋을 완벽하게 처리하거나
  - 못할 경우 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.

- 잠금 : 동시성을 제어하기 위한 기능
  - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.
  - 격리 수준이란 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미한다.

# 트랜잭션

## MySQL에서의 트랜잭션

논리적인 작업 셋 자체가 100%적용되거나(COMMMIT), 아무것도 적용되지 않아야(ROLLBACK)함을 보장해주는 것
트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. (트랜재션의 범위를 최소화)

## MySQL 엔진의 잠금

MySQL에서 사용되는 잠금

1. 스토리지 엔진 레벨
   - 스토리지 엔진 간 상호 영향을 미치지는 않는다.
2. MySQL 엔진 레벨 (db서버에서 스토리지 엔진을 제외한 나머지 부분)
   - 모든 스토리지 엔진에 영향을 미친다
   - 테이블 데이터 동기화를 위한 테이블 락 이외에도 테이블의 구조를 잠그는 메타데이터 락, 사요자의 필요 맞게 사용할 수 있는 네임드 락을 제공한다.

### 클로벌 락

MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL, DML문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
영향을 미치는 범위는 MySQL서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더락도 동일하게 영향을 미친다.

### 테이블 락

개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.

묵시적인 테이브 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용된다.

### 네임드 락

함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
네임드 락은 단순리 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.

## InnoDB 스토리지 엔진 잠금

MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.
하지만 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용된느 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다롭다.

하지만 최근 버전에서는 InnoDB의 트랜잭션과 잠금, 그릭 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입됐다.
information_schema 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 어떤 잠금을 대시하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있으며, 또한 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료시킬 수도 있다. 그리고 조금씩 업그레이드되면서 InnoDB의 중요도가 높아졌고, InnoDb의 잠금에 대한 모니터링도 강화되면서 Perfomance Schema를 이용해 InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법도 추가됐다.

### InnoDB 스토리지 엔진의 잠금

레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우는 없다.
일반 상용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭락이라는 것이 존재

<img src = "../hyeyeon_images/innoDb잠금의 종류.png">

#### 레코드 락

레코드 자체만을 잠그는 것을 레코드 락이라고하며, 다른 사용 DBMS의 레코드 락과 동일한 역할을 한다. 한 가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.
인덱스를 이용해 잠금을 설정한다. 많은 사용자가 간과하는 부분이지만 레코드 자체를 잠그느냐, 아니면 인덱스를 잠그느냐는 상당히 크도 중요한 차이를 만들어 낸다.

#### 갭 락

레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만의 잠그는 것을 의미한다.
갭락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사의 간격만을 잠그는 것을 의미한다.
갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다 .

#### 넥스트 키 락

레코드 락과 갭락을 합쳐 놓은 형태의 잠금
InnoDb의 갭락이나 넥스트 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.
가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭락을 줄이는 것이 좋다.

#### 자동 증가 락

AUTO_INCREMENT 칼럼이 사용된 테이블에 여러 레코드가 INSERT될 경우 각 레코드는 중복되지 않고 순차적인 값을 가져야하는데 이를 위해 자동 증가 락을 사용한다.

시스템 변수를 통해 서버가 INSERT되는 레코드 건수를 정확히 예측할 수 있을 때는 자동 증가 락 대신 래치(뮤텍스)를 이용하여 처리하게 할 수 있다.

#### 인덱스와 잠금

InnoDB의 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식으로 처리된다.

// employees 테이블의 first_name 컬럼에만 index가 있는 상태
UPDATE employees
SET hire_date = NOW()
WHERE first_name = 'Georgi' AND last_name = 'Klassen';
// -> 1개의 row 업데이트
위 상황에서는, first_name이 Georgi인 모든 레코드를 잠그고 last_name이 Klassen인 레코드를 찾는다.

→ 인덱스가 적절히 설정되어 있지 않으면 잠금의 범위가 커져서 동시성이 떨어진다.

만약 아예 인덱스가 없다면 테이블을 풀스캔하며 UPDATE 작업을 하는데, 이 과정에서 모든 레코드를 잠궈버린다.

→ 잠금의 범위를 최소화할 수 있도록 인덱스 설계를 잘 해야한다.

## MySQL의 격리 수준

트랜잭션의 격리 수준이란, 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 다루는 데이터를 볼 수 있게 허용할지를 결정하는 것을 말한다.

### 격리 수준의 종류와 세 가지 문제점

|                  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ   |
| ---------------- | ---------- | ------------------- | -------------- |
| READ UNCOMMITTED | O          | O                   | O              |
| READ COMMITTED   | X          | O                   | O              |
| REPEATABLE READ  | X          | X                   | O (InnoDB는 X) |
| SERIALIZABLE     | X          | X                   | X              |

4가지의 격리 수준에서 아래로 갈 수록 격리 수준이 높아지고 동시 처리 성능이 떨어진다.

READ UNCOMMITTED는 거의 사용X, SERIALIZABLE는 동시성이 중요한 경우엔 거의 사용하지 않는다.

### 격리 수준의 종류

#### READ UNCOMMITTED

<img src = "https://github.com/JeongHunHui/TIL/assets/108508730/521c0ebb-2563-4799-91e6-70f332eb3a1f">

READ UNCOMMITTED 격리 수준에서는 각 트랜잭션에서의 변경 내용이 COMMIT, ROLLBACK 여부에 상관없이 다른 트랜잭션에서 조회할 수 있다.

→ 아직 COMMIT되지 않은 내용이 조회되는 DIRTY READ 문제가 발생할 수 있다.

→ 만약 오류로 인해 ROLLBACK 되더라도 이미 조회한 다른 사용자는 잘못된 정보를 가지게 된다.

MySQL을 사용한다면 최소한 READ COMMTIED 이상의 격리 수준을 사용할 것을 권장한다.

#### READ COMMITTED

<img src = "https://github.com/JeongHunHui/TIL/assets/108508730/14c00054-0a3f-4f90-81ca-8837184ce0cb">

READ UNCOMMITTED 격리 수준에서는 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.

새로운 데이터가 들어오면 변경 전 데이터는 언두 로그에 저장하고, COMMIT 되기전에 다른 트랜잭션에서 조회하면 언두 로그에 있는 변경 전 데이터를 반환한다.

→ 하나의 트랜잭션 안에서 동일한 SELECT 쿼리로 데이터를 요청하면 항상 같은 결과를 가져오지 못하는 문제인 NON-REPEATABLE READ 문제가 발생할 수 있다. - REPEATABLE READ 정합성에 어긋나는 것이다

일반적인 웹 서비스에선 큰 문제가 아닐 수 있지만 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.

참고로, 오라클 DBMS의 기본 격리 수준이자, 온라인 서비스에서 가장 많이 사용되는 격리 수준이다.

#### REPEATABLE READ

<img src = "https://github.com/JeongHunHui/TIL/assets/108508730/585e69ad-4729-4e05-a66f-1cc7919bba55">

REPEATABLE READ 격리 수준에서는 트랜잭션 Id를 기준으로 자신 이후에 발생한 트랜잭션에서의 변경사항은 읽지 않는다.

→ 동일 트랜잭션 내에서는 동일한 결과를 보여줌을 보장한다.

원래 REPEATABLE READ는 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 PHANTOM READ 현상이 발생하지만 InnoDB에선 일부 특별한 쿼리(FOR UPDATE 등)를 제외하고는 발생하지 않는다.

참고로 InnoDB에서 기본으로 사용되는 격리 수준이다.

#### SERIALIZABLE

SERIALIZABLE 격리 수준에선 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없다.

읽기 작업에도 읽기 잠금을 획득해야하므로 동시 처리 성능이 매우 떨어진다.

InnoDB는 갭 락과 넥스트 키 락 덕분에 PHANTOM READ가 발생하지 않기 때문에 사용할 이유가 없다.
