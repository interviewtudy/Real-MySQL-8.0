# 트랜잭션

- MyISAM이나 MEMORY는 트랜잭션을 지원하지 않음

## MySQL에서의 트랜잭션

- 트랜잭션은 쿼리 개수와 관계 없잉 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것
- 부분 업데이트 현상이 발생하면 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리 작업이 필요할 수 있음

## 주의사항

- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋음 -> 트랜잭션 범위를 최소화
- 각 단위 프로그램이 커넥션을 소유하는 시간을 최소화 하여 여유 커넥션의 개수를 확보하는 것이 좋음
- 메일 전송, 네트워크 통신 작업은 트랜잭션 내에서 제거하는 것이 좋음
- 저장, 조회 등 성격에 따라 별도의 트랜잭션으로 분리하는 것이 좋음

<br/><br/><br/><br/>

# MySQL에서의 잠금

- 스토리지 엔진 레벨
  - 스토리지 엔진간 사옿 영향을 미치지 않음
- MySQL 엔진 레벨
  - 모든 스토리지 엔진에 영향을 미침
  - 테이블 데이터 동기화를 위한 테이블 락, 테이블 구조를 잠그는 메타데이터 락, 사용자 필요에 맞게 사용할 수 있는 네임드 락이라는 잠금 기능을 제공

## 글로벌락

- `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있음
- MySQL에서 제공하는 잠금 가운데 가장 범위가 큼
- 한 세션이 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 핻아 문장이 대기 상태로 남음
- 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체로 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미침
- 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 `mysqldump` 로 일관된 백업을 받아야할 때 글로벌락을 사용
- InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 데이터 변경 작업을 멈출 필요는 없음
- MySQL 8.0부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생김 -> Xtrabackup 이나 Enterprise Backup과 같은 백업툴들의 안정적인 실행을 위해 백업 락이 도입됨
- 특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없음. 단 일반적ㅇ니 테이블의 데이터 변경은 허용
- MySQL 서버는 소스 서버와 레플리카 서버로 구성되고 백업은 레플리카 서버에서 실행
- 백업 락은 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실해오디면 복제를 일시 중지하는 역할을 함

<br/><br/>

## 테이블 락

- 개별 테이블 단위로 설정되는 장금으로 명시적 목적 또는 묵시적으로 특정 테이블 락을 획득할 수 있음
- MyISAM, InnoDB 모두 동일하게 설정 가능
- 명시적으로는 `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 획득, `UNLOCK TABLES` 명령으로 반납
- 묵시적으로는 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 던지면 발생함
- InnoDB 테이블은 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적 테이블 락이 설정되진 않고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향ㅇ르 미침

<br/><br/>

## 네임드 락

- `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있음
- 테이블, 레코드, 데이터베이스 객체 등이 아닌 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용됨
- 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되고, 각 프로그램의 실행 시간을 분산하거나 프로그램의 코드를 수정해서 데드락을 최소화할 수 있지만 간단하지 않고 완전한 해결책이 될 수 없음 -> 동일 데이터를 변경/참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 해결 가능
- 8.0부터 네임드 락 중첩해서 사용할 수 있고, 획득한 네임드 락을 한번에 해재할 수 있음

<br/><br/>

## 메타데이터 락

- 데이터베이스 객체(테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
- 명시적으로 획득/해제할 수 없고 `RENAME TABLE tab_a to tab_b` 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금

<br/><br/><br/><br/>

# InnoDB 스토리지 엔진 잠금

- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과 별개로 내부에서 레코드 기반의 잠금 방식을 탑재하고 있음
- MyISAM보다 훨씬 뛰어난 동시성 처리를 제공할 수 있음
- 이원화된 잠금 때문에 MySQL 명령을 이용해서 잠금에 대한 정보에 접근하기 상당히 까다로움
- 최근 버전에서는 InnoDB의 트랜잭션과 잠금, 잠기 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입 됨
- InnoDB의 중요도가 높아지고, 잠금에 대한 모니터링도 더 강화되면서 `Performance schema`를 이용해 InnnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법도 추가됨

## InnoDB 스토리지 엔진의 잠금

- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하고, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락이나 테이블 락으로 레벨업 되는 경우(락 에스컬레이션)가 없음
- 일반 상용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코 락뿐 아니라 레코드와 레코드 사이 간격을 잠그는 갭 락이 존재함

### 레코드 락

- 레코드 자체만을 잠그는 것으로 다른 상용 DBMS의 레코드 락과 동일한 역할을 하되, InnoDB 스토리지 엔진은 레코드 자체가 아닌 인덱스의 레코드를 잠근다는 차이가 있음
- 인덱스가 하나도 없는 테이블이라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정함
- 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 이용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서 잠그지 않고 레코드 자체에만 락을 검

### 갭 락

- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 역할을 함
- 갭 락은 자체적으로 쓰기보단 넥스트 키 락의 일부로 자주 사용됨

### 넥스트 키 락

- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적
- 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생함 -> 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋음

### 자동 증가 락

- AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 하는데, InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 자동 증가 락이라는 테이블 수준의 잠금을 사용함
- INSERT, REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하고 UPDATE나 DELETE 등의 쿼리에서는 걸리지 않음
- 자동 증가 락은 레코드 락이나 넥스트 키 락과는 달리 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨
- 자동 증가 락은 테이블에 단 하나만 존재하기 때문에 하나의 쿼리가 락을 걸면 나머지 쿼리는 기다려야 함
- 5.0까지는 명시적으로 자동 증가 락을 획득하고 해제하는 방법은 없었지만 5.1부터는 `innodb_autoinc_lock_mod` 라는 시스템 변수를 통해 자동 증가 락의 작동 방식을 변경할 수 있음
  - innodb_autoinc_lock_mod=0: 5.0과 동일한 방식
  - innodb_autoinc_lock_mod=1: MySQL 서버가 INSERT되는 레코드의 건수를 정확히 예측할 수 있ㅇ르 땐 자동 증가 락 대신 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 처리함
  - innodb_autoinc_lock_mod=2: 자동 증가 락 대신 뮤텍스를 사용. 연속된 자동 증가 값을 보장하진 못하고 유니크한 값이라는 것만 보장

<br/><br/>

## 인덱스와 잠금

- 레코드 자체를 잠금하지 않고 인덱스를 잠금하는 방식이므로, 변경할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 함
- 인덱스가 없다면 테이블을 풀 스캔하면서 작업을 수행하므로 모든 레코드가 잠김

### 레코드 수준의 잠금 확인 및 해제

- 테이블 잠금에서는 잠금의 대상이 테이블 자체이므로 쉽게 문제의 원인이 발견되고 해결될 수 있지만 레코드 수준의 잠금은 테이블의 레코드 각각에 잠김이 걸리므로 자주 사용되지 않는 레코드는 오랜 시간 잠겨있어도 잘 발견되지 않음
- 예전 버전의 MySQL 서버에서는 레코드 잠금에 대한 메타 정보(딕셔너리 테이블)를 제공하지 않아 더욱 어려웠지만 5.1버전 부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나만 실행해보면 잠금과 잠금 대기를 바로 확인할 수 있음
- `KILL` 명령을 통해 MySQL 서버의 프로세스를 강제 종료하면 강제로 잠금을 해제할 수 있음
- 버전 별 잠금과 잠금 대기 정보 확인
  - 5.1: information_schema라는 DB에 INNODB_TRX라는 테이블과 INNODB_LOCKS, INNODB_LOCK_WAIT라는 테이블을 통해 확인이 가능
  - 8.0: information_schema가 조금씩 Deprecated 되고 performance_schema의 data_locks와 data_lock_waits 테이블로 대체되고 있음

<br/><br/><br/><br/>

# MySQL의 격리 수준

- 격리 수준: 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것
- 격리 수준은 4가지로 나뉨 -> `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`
- `DIRTY READ`라고도 하는 `READ UNCOMMITTED`는 일반적인 데이터베이스에서 거의 사용하지 않고 `SERIALIZABLE` 또한 동시성이 중요한 데이터베이스에선 거의 사용되지 않음

| 격리 수준 종류   | 격리 정도 | 동시 처리 성능 | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ        |
| ---------------- | --------- | -------------- | ---------- | ------------------- | ------------------- |
| READ UNCOMMITTED | 낮음      | 높음           | 발생       | 발생                | 발생                |
| READ COMMITTED   |           |                | 없음       | 발생                | 발생                |
| REPEATABLE READ  |           |                | 없음       | 없음                | 발생(InnoDB는 없음) |
| SERIALIZABLE     | 높음      | 낮음           | 없음       | 없음                | 없음                |

- DIRTY READ: 각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보임
- NON-REPEATABLE READ: 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성을 위배하는 것
- PHANTOM READ(PHANTOM ROW): 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상

## READ UNCOMMITTED

- 더티 리드가 발생하는 격리 수준으로 RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많음
- MySQL을 사용한다면 최소한 READ COMMITTED 이상의 격리 수준을 사용할 것을 권장

## READ COMMITTED

- 오라클 DBMS에서 기본으로 사용되는 격리 수준이자 온라인 서비스에서 가장 많이 선택되는 격리수준
- 더티 리드가 발생하지 않으므로 변경 내용이 커밋되기 전까지는 언두 영역에 백업된 레코드에서 데이터를 가져옴
- 하나의 트랜잭션에서 같은 SELECT 쿼리를 던져도 다른 결과를 가져올 수 있음(커밋 전 후 다른 데이터 가져올 수 있음)

### REPEATABLE READ

- MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- 바이너리 로그를 가진 MySQL 서버에서는 REPEATABLE READ 격리 수준 이상을 사용해야 함
- InnoDB 스토리지 엔진은 트랜잭션이 롤백될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경함(MVCC)
- READ COMMITTED와 REPEATABLE READ는 모두 MVCC를 이용해 커밋 전 데이터를 보여주지만, 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가느냐는 부분에서 차이가 있음
- InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지고, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함되어 있음
- 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제됨
- REPEATABLE READ에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없음.
- SELECT ... FOR UPDATE 쿼리는 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드엔 잠금을 거러 수 없음

### SERIALIZABLE

- 순수한 SELECT 작업은 아무런 레코드 잠금도 설정하지 않고 실행됨
- 읽기 작업도 공유 잠금을 획득해야 하므로 PHANTOM READ라는 문제가 발생하지 않음
- InnoDB 스토리지 엔진에서는 REPEATABLE READ 격리 수준에서도 PHANTOM READ가 발생하지 않기 때문에 사용할 필요 없음
