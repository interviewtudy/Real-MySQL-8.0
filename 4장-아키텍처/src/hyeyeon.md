# MySQL 엔진 아키텍쳐

## MySQL의 전체 구조

<img src = "https://velog.velcdn.com/images/klm03025/post/483e71e1-7df5-411c-aec8-33d16fee9958/image.png">

MySQL은 크게

1. MySQL 엔진: 요청된 SQL 문장을 분석/최적화 하고, 연결을 관리함.

   - 커넥션 핸들러: 클라이언트로부터의 접속 및 쿼리 요청
   - SQL 파서 및 전처리기
   - 옵티마이저: 쿼리의 최적화된 실행을 위한 최적화기

2. 스토리지 엔진: 실제 데이터를 스토리지에 저장하고, 읽어옴.
   - MySQL 엔진은 하나지만, 스토리지 엔진은 필요에 따라 여러 가지를 바꿔 쓸 수 있음.
   - 각 스토리지 엔진은 성능 향상을 위해 키 캐시나 버퍼 풀 같은 기능을 내장함.
   - MySQL 엔진의 쿼리 실행기에서 실 데이터를 읽어야 할 땐, 핸들러 API를 이용해 스토리지 엔진에 실제 I/O를 요청함.

이렇게 둘을 합쳐서 그냥 MySQL로 뭉뜽그려 부름

### MySQL 스레딩 구조

<img src = "https://velog.velcdn.com/images/klm03025/post/95a0c886-538b-4e8d-9075-be4ca615a604/image.png">

MySQL서버는 스레드 기반으로 포그라운드 스레드와 백그라운드 스레딩으로 구분할 수 있다.
동일한 이름의 스레드가 2개 이상 있다면, 서버의 설정하에 여러 스레드가 병렬 처리하는 것을 의미함.

1. 포그라운드(클라이언트) 스레드
   foreground 스레드의 최소 수는 MySQL 서버에 접속된 클라이언트의 수이며, 주로 쿼리 문장을 처리함.
   커넥션을 종료한다고 바로 스레드가 사라지는 것은 아니며, 스레드 캐시에 최근에 연결이 종료된 몇개의 스레드를 위치시킴.
   데이터를 버퍼나 캐시로부터 가져오고, 없다면 직접 디스크의 데이터나 인덱스 파일에서 읽어옴.
   MyISAM일 경우 디스크 쓰기 작업까지 foreground가 처리하나, InnoDB는 이를 백그라운드로 위임시킴.

2. 백그라운드 스레드
   background 스레드의 경우, (InnoDB의 경우) 다양한 작업들이 백그라운드로 처리된다.
   이 중 Log Thread, Write Thread (버퍼의 데이터를 디스크에 씀) 는 정말 중요함.
   사용자의 요청을 처리할 때, 쓰기 작업은 지연 처리가 가능하나 읽기는 불가능함.
   따라서, 일반적으로 쓰기 연산은 버퍼링하여 일괄 처리를 진행하고, InnoDB 또한 그러함.
   다만 MyISAM은 foreground 스레드가 쓰기 작업까지 함께 처리함.

### 메모리 할당 및 사용 구조

<img src= "https://velog.velcdn.com/images/klm03025/post/d47cdea9-d321-4da1-ba37-7bb6e5542141/image.png>

MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있음.
모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당됨.

1. 글로벌 메모리 영역  
   클라이언트 스레드의 수와 무관
   필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만, 일반적으로는 하나만 할당됨.
   글로벌 영역이 많더라도 모든 스레드에 의해 공유됨.
   대표적인 영역은 다음과 같음.
   (테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼)

2. 로컬 메모리 영역
   세션 메모리 영역이라고 하며, 서버상에서 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용함.
   클라이언트가 MySQL 서버에 접속하면 MySQL 서버에서는 클라이언트 커넷션으로부터의 요청을 처리하기 위해 스레드를 할당함.
   절대 공유되어 사용되지 않음.
   메모리 공간을 크게 신경 쓰지 않고 설정됨.
   쿼리의 용도에 따라 필요할 때만 할당되며, 상황에 따라 용량이 아예 할당되지 않을 수도 있음.
   대표적인 영역은 다음과 같음
   (정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼)

### 플러그인 스토리지 엔진 모델

<img src= "https://velog.velcdn.com/images/klm03025/post/39029851-172c-4465-a0c2-719789ea282f/image.png">
플러그인 모델을 갖고 있으며, 인증 및 검색어 파서등이 플러그인 형태로 개발되어 있다.
MySQL에서 쿼리가 실행되는 과정을 정리하면 대부분의 작업이 MySQL 엔진에서 처리되며, 마지막 데이터 읽기/쓰기 작업만 스토리지 엔진에 의해 처리됨.
SQL 파서 → SQL 옵티마이저 → SQL 실행기 순으로 MySQL 엔진에서 처리되고, 이후 데이터 읽기/쓰기만 스토리지 엔진에서 처리된다고 보면 됨.
대부분의 데이터 읽기/쓰기 작업은 대부분 1건의 레코드 단위로 처리됨.
스토리지 엔진을 변경한다고 해서 작업의 결과물이 바뀌는 것은 아니며, 처리 방법의 차이만 있을 뿐임.
실질적으로 복잡한 연산인 GROUP BY나 ORDER BY 등의 처리는 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리됨.
SHOW ENGINE을 사용하면, 현재 설치된 서버가 지원하는 스토리지 엔진을 확인할 수 있다.

### 컴포넌트

플러그인 구조는 좋지만, 일부 단점이 있음.
플러그인은 오직 MySQL 서버와만 소통 가능하며, 플러그인끼리는 통신할 수 없음
플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음 (캡슐화 X)
플러그인의 상호 의존 관계 설정이 불가능하여 초기화가 어려움
8.0 부터 컴포넌트 구조가 나오면서, 앞에서 설명한 비밀번호 검증 기능등이 컴포넌트로 변경됨.

### 쿼리 실행 구조

<img src ="https://velog.velcdn.com/images/klm03025/post/9e89a6aa-23bb-406f-82d5-432100c98e4e/image.png">
쿼리 파서: 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어냄.
기본 문법 오류는 이 단계에서 발견되어 오류 메시지를 전달함.
전처리기: 파서 과정에서 만들어진 파서 트리를 기반으로 구조적인 문제가 있는지 확인함.
또한, 토큰을 실제 이름 및 개체등과 매핑해 객체의 존재 여부와 접근 권한등을 확인함.
옵티마이저: 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할 수 있도록 결정함.
이 책의 상당수 내용은 옵티마이저와 관련되어 있음.
실행 엔진: 실제 동작과 관련 있음.
예를 들어, 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용한다면,
실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
실행 엔진은 그와 동시에 WHERE 절과 일치하는 레코드를 가져오라고 핸들러에게 요청
읽어온 레코드들을 1번에서 준비한 테이블에 저장하라고 핸들러에게 요청
데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 요청
최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
핸들러: MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어 오는 역할을 함 → 사실상 스토리지 엔진!

#### 스레드 풀

정작 커뮤니티 에디션엔 없음
일반적인 서버에서의 스레드 풀과 유사함

#### 트랜잭션 지원 메타데이터

데이터베이스 서버에서 테이블의 구조 정보와 Stored Program 등의 정보를 데이터 딕셔너리/메타데이터라고 함.
5.7 까지는 구조를 FRM 파일에 저장하고 일부 Stored Program 의 정보 또한 파일로 저장함.
다만, 이런 구조는 트랜잭션을 지원하지 않았기에 생성 도중에 문제가 생기면 정합성에 문제가 생김
8.0 부터는 테이블의 구조 정보나 Stored Program의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선됨.
시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql 이라는 이름의 DB에 저장하며, 이 DB의 정보는 mysql.ibd 라는 이름의 테이블 스페이스에 저장됨.
그렇기에 해당 파일은 잘 관리해야 함!
참고로, 데이터 딕셔너리는 저장은 되지만 사용자의 임의 수정을 막기 위해 테이블을 보여주지 않으며, 대신 information_schema DB의 TABLES/COLUMNS 등과 같은 뷰를 통해서 조회할 수 있도록 함.

또한 테이블에 대해 접근을 시도하면 권한이 없다고 뜸
물론 InnoDB를 사용한다고 해도, 다른 스토리지 엔진의 메타 정보는 다른데다 저장해야 함.
MySQL 서버는 InnoDB 엔진 이외의 스토리지 엔진을 사용하는 테이블을 위해 SDI (Serialized Dictionary Information) 파일을 사용하는데, 이는 기존의 FRM 파일과 동일한 역할을 함.

# InnoDB 스토리지 엔진 아키텍쳐

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공함.
따라서, 높은 동시성 처리가 가능함.

<img src = "https://velog.velcdn.com/images/klm03025/post/c22e70b8-b086-42cc-ae31-c367b88fd4a1/image.png">

## Primary 키에 의한 클러스터링

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 있음.
프라이머리 키를 기준으로 순서대로 디스크에 저장됨.
모든 세컨더리 인덱스는 프라이머리 키의 값을 논리적인 주소로 사용함.
그러다보니, 프라이머리 키를 이용한 Range Scan 은 빠르게 처리 될 수 있음.
MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않음.
따라서, 프라이머리 키와 세컨더리 인덱스는 구조적으로 차이가 없음.
클러스터링?
어떤 정해진 컬럼 값을 기준으로 동일한 값을 가진 하나 이상의 테이블의 레코드를 같은 장소에 저장하는 물리적인 기법
즉, 여기서는 PK 값에 의해 특정 레코드의 물리적인 저장 위치가 정해진다고 보면 됨.
B-Tree 구조를 채택하지 않고, 루트 노드 - 리프 노드 구조로만 구성되어 있음.
PK 값을 수정하게 되면 데이터의 물리적인 위치가 바뀌게 되므로, 절대 그러지 말자!
정확히는 DELETE 후 INSERT 진행함.

### 외래 키 지원

놀랍게도 외래 키에 대한 지원은 스토리지 엔진 레벨에서 진행 됨.
즉, MyISAM 이나 다른 스토리지 엔진에는 지원하지 않을 수도 있음!
다만 InnoDB 기준, 외래 키는 부모 및 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 과정에서 양쪽을 모두 확인하는 과정을 거치기 때문에 여러 테이블에 Lock이 전파될 위험이 있음.
만약 시스템 적으로 긴급한 조치가 필요할 경우, foreign_key_checks 라는 시스템 변수를 OFF로 설정하여 체크 작업을 멈출 수 있음.
이런 처리를 할 경우 부가적인 체크가 필요하지 않기 때문에 빠르게 처리할 수 있으나, 부모 및 자식 테이블의 정합성 또한 수동으로 처리해야 한다.
ON DELETE CASCADE 또한 해제되기 때문에, 더더욱 수동으로 관리해야 함.

### MVCC (Multi-Version Concurrent Control)

MVCC의 가장 큰 목적은 Lock을 사용하지 않는 일관된 읽기를 제공하는 것.
InnoDB는 Undo Log를 이용해 이 기능을 구현함.
READ COMMITED 상태의 Isolation Level을 보인다고 가정해보자.
이게 디폴트
UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값으로 업데이트 됨.
<img src = "https://velog.velcdn.com/images/klm03025/post/388f8aa8-9e06-4822-9f4f-edf75dc3f33d/image.png">
