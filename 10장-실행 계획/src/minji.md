# 통계 정보

- 5.7버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립 -> 테이블 칼럼의 값들이 어떻게 분포돼 있는지에 대한 정보가 없어 정확도가 떨어지는 경우가 많았음
- 8.0부터 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됨

## 테이블 및 인덱스 통계 정보

- 통계 정보는 비용 기반 최적화에서 가장 중요함
- MySQL은 비용 기반 최적화를 사용했지만 다른 DBMS보다 통계 정보의 정확도가 높지 않고 휘발성이 강했음 -> 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완하여 사용

### MySQL 서버의 통계 정보

- 5.6버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됨
- 5.5버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고 SHOW INDEX 명령으로만 인덱스 칼럼의 분포도를 볼 수 있었음 -> 메모리에 저장되었기에 서버 재시작시, 통계 정보가 모두 사라졌음
- 5.6버전부터는 각 테이블의 통계 정보를 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리 -> 서버 재시작해도 기존 통계 정보 유지 가능
- 5.6버전에서 테이블 생성 시 `STATS_PERSISTENT` 옵션으로 테이블 단위로 영구적인 통계 정보를 보관할지 여부를 결정할 수 있음
  - 0: 5.5버전 이전 방식대로 관리. 테이블에 저장하지 않음
  - 1: innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리 (기본값)
  - 2: STATS_PERSISTENT 옵션을 설정하지 않은 것과 같음. 영구적으로 관리할지 여부를 innodb_stats_persistent 시스템 변수의 값으로 결정
- ALTER TABLE 명령으로 STAT_PERSISTENT를 1 또는 0으로 변경할 수 있음
- 테이블이 새로 오픈되거나 테이블의 레코드가 대량으로 변경되거나 ANALYZE TABLE 명령어가 실행되는 등의 이벤트가 발생하면 자동으로 통계 정보가 갱신됨
- innodb_stats_auto_recalc 시스템 변수를 OFF 로 설정하면 통계 정보 자동 갱신을 막을 수 있음
- 테이블 생성시 STATS_AUTO_RECALC 옵션을 이용해 테이블 단위로 통계 정보 자동 수집 여부를 조정할 수 있음
- 5.5버전에서 샘플링하는 테이블 블록 개수를 설정하는 innodb_stats_sample_pages 가 5.6버전부터는 innodb_stats_transient_sample_pages, innodb_stats_persistent_sample_pages 로 분리됨
  - innodb_stats_transient_sample_pages: 기본값이 8로, 자동으로 통계 정보 수집이 실행될 때 8개 페이지만 임의로 샘플링해서 분석하고 그 결과를 통계 정보로 활용함
  - innodb_stats_persistent_sample_pages: 기본값이 20으로, ANALYZE TABLE 명령이 시랳오디면 임의로 20개 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장하고 활용함
- 영구적인 통계 정보를 사용한다면 MySQL 서버 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보 수집이 가능함
- innodb_stats_persistent_sample_pages 시스템 변수에 높은 값을 설정하면 더 정확한 통계 정보 수집이 가능하지만 시간이 길어짐

<br/><br/>

## 히스토그램

- 5.7버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었음 -> 최적의 실행 계획을 수립하기엔 부족 -> 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식 사용
- 8.0버전부터 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 됨

### 히스토그램 정보 수집 및 삭제

- 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리되고, 자동으로 수집되는 것이 아니라 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리됨
- 수집된 히스토그램 정보는 시스템 딕셔너리에 함꼐 저장되고 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드함
- 8.0 버전의 히스토그램 타입
  - Singleton(싱글톤 히스토그램)
    - 칼럼값 개별로 레코드 건수를 관리하는 히스토그램. Value-Based 히스토그램 또는 도수 분포라고 불림
    - 각 버킷이 칼럼의 값과 발생 빈도 비율의 2개 값을 가짐
    - 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용됨
  - Equi-Height(높이 균형 히스토그램)
    - 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램. Height-Balanced 히스토그램이라고도 불림.
    - 각 버킷이 범위 시작 값과 마지막 값, 발생 빈도율과 각 버킷에 포함된 유니크 값의 개수 등 4개의 값을 가짐
    - 각 범위에 대해 레코드 건수 비율이 누적으로 표시됨
- information_schema.column_statistics 테이블의 HISTOGRAM 칼럼이 가진 나머지 필드
  - sampling-rate: 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율. 크기가 커질수록 정확한 히스토그램이지만 스캔에는 자원이 많이 소모됨
  - histogram-type: 히스토그램의 종류를 저장
  - number-of-buckets-specified: 히스토그램을 생성할 때 설정했던 버킷의 개수를 저장함. 기본값은 100이며 일반적으로 충분한 수치
- 히스토그램의 삭제
  - ANALYZE TABLE .. DROP HISTOGRAM ON .. 을 통해 삭제
  - 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 성능에 영향을 주지 않고 즉시 완료됨
  - 삭제하지 않고 옵티마이저가 히스토그램을 사용하지 않게 하려면 optimizer_switch 시스템 변수의 값을 변경하면 됨. 글로벌로 변경하면 서버의 모든 쿼리가 히스토그램을 사용하지 않고, condition_fanout_filter 옵션에 의해 영향받는 다른 최적화 기능들이 사용되지 않을 수 있음

### 히스토그램의 용도

- 히스토그램 정보가 없으면 옵티마이저는 균등하게 분포돼 있을 것으로 예측함
- 인덱스되지 않은 칼럼에 히스토그램이 없다면 옵티마이저는 칼럼들의 데이터 분포를 전혀 알지 못하고 실행 계획을 수립하기 때문에 좋지 않은 방향으로 조인의 드라이빙 테이블을 결정하게 됨 -> 쿼리의 성능이 10배 정도 차이를 보일 수 있음

### 히스토그램과 인덱스

- 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택함
- 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴봄(인덱스 다이브)
- 8.0 서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우 그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용함 -> 실제 검색 조건의 대상 값에 대한 샘플링이므로 항상 히스토그램보다 더 정확한 결과를 기대할 수 있음
- 인덱스 다이브는 어느 정도의 비용이 필요하고 실행 계획 수립만으로도 상당히 많은 인덱스 다이브를 실행해 비용이 그만큼 커짐

<br/><br/>

## 코스트 모델(Cost Model)

전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용

- 5.7 이전 버전까지는 작업들의 비용을 서버 소스 코드에서 상수화해서 사용했음 -> 하드웨어에 따라 달라질 수 있어 고정된 비율을 일률적으로 적용하는 것은 최적의 실행 계획 수립에 있어 방해 요소
- 5.7 버전부터는 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있기 개선. 인덱스되지 않은 칼럼의 히스토그램이나 메모리에 상주 중인 페이지의 비율 등 비용 계싼과 연관된 부분의 정보가 부족
- 8.0 버전에서는 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되어 옵티마이저의 실행 계획 수립에 사용됨
- 8.0 서버의 코스트 모델의 설정값(mysql DB에 존재)
  - server_cost: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
  - engine_cost: 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리
- server_cost 테이블과 engine_cost 테이블의 공통 칼럼
  - cost_name: 코스트 코델의 각 단위 작업
  - default_value: 각 단위 작업의 비용(기본값. 서버 소스 코드에 설정된 값)
  - cost_value: DBMS 관리자가 설정한 값(null 이면 default_value 칼럼의 비용 사용)
  - last_updated: 단위 작업 비용이 변경된 시점
  - comment: 비용에 대한 추가 설명
- engine_cost 만 갖는 칼럼
  - engine_name: 비용이 적용된 스토리지 엔진. 스토리지 엔진별로 각 단위 작업의 비용을 설정할 수 있음.
  - device_type: 디스크 타입. 8.0에선 아직 값을 활용하지 않고 0만 설정할 수 있음
- 8.0버전의 코스트 모델에서 지원하는 작업 단위: 디스크 데이터 페이지 읽기, 메모리 데이터 페이지 읽기, 디스크 임시 테이블 생성, 디스크 임시 테이블의 레코드 읽기, 인덱스 키 비교, 메모리 임시 테이블 생성, 메모리 임시 테이블의 레코드 읽기, 레코드 비교
- 코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악해야 함

<br/><br/><br/><br/>

# 실행 계획 확인

## 실행 계획 출력 포맷

- 8.0 이전 버전에서는 EXPLAIN EXTENDED 또는 EXPLAIN PARTITIONS 명령이 구분됐지만 8.0부터는 통합되어 보이도록 개선되면서 두 옵션이 제거됐음
- 8.0 버전 부터는 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON, TREE, 테이블 형태로 선택 가능함

<br/><br/>

## 쿼리의 실행 시간 확인

- EXPLAIN ANALYZE: 쿼리의 실행 계획과 단계별 소요 시간 정보를 확인할 수 있는 기능으로 8.0.18 버전부터 추가됨
- SHOW PROFILE 명령은 어떤 부분에서 시간이 많이 소요되는지는 보여주지만, 단계별로 소요된 시간 정보를 보유주진 않음
- 결과는 항상 TREE 포맷으로 출력됨
- TREE 포맷에서 들여쓰기는 호출 순서로, 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행, 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행됨
- EXPLAIN ANALYZE 명령의 결과에는 단계별로 실제 소요된 시간(actual time)과 처리한 레코드 건수(rows), 반복 횟수(loops)가 표시됨
- EXPLAIN ANALYZE 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여줌
- 쿼리의 실행 시간이 아주 많이 걸리는 쿼리면 EXPLAIN ANALYZE 명령에선 쿼리가 완료돼야 실행 계획의 결과를 확인할 수 있으므로 쿼리의 실행 계획이 나쁜 경우에는 EXPLAIN 명령으로 실행 계획만 확인해서 튜닝 후 EXPLAIN ANALYZE 명령을 실행하는 편이 좋음

<br/><br/><br/><br/>

# 실행 계획 분석

## id 칼럼

- 실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 SELECT 쿼리별로 부여되는 식별자 값
- 하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여됨
- 여러 개의 SELECT 문장이라면 그 개수만큼 각각 다른 id 값을 지님
- 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하는 것은 아님

<br/><br/>

## select_type 칼럼

SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼

- SIMPLE: UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT. 쿼리 문장이 복잡하더라도 실행 계획에서 SIMPLE 인 단위 쿼리는 하나만 존재(일반적으로 가장 바깥 SELECT 쿼리)
- PRIMARY: UNION이나 서브쿼리를 가지는 SELECT 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리. SIMPLE 과 마찬가지로 하나만 존재
- UNION: UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리. 첫 번째의 경우 임시 테이블(DERIVED)이 표시됨
- DEPENDENT UNION: UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시됨. DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미
- UNION RESULT: UNION 결과를 담아두는 테이블. MySQL 8.0 이전 버전에서는 UNION ALL과 UNION 쿼리는 모두 UNION 결과를 임시 테이블로 저장했는데, 8.0부터는 UNION ALL의 경우 임시테이블을 사용하지 않도록 개선됨. 하지만 UNION은 여전히 임시 테이블을 사용하므로 실행 계획상에서 이 임시 테이블을 가리키는 라인의 select_type임. 단 실제 쿼리에서 단위 쿼리가 아니므로 별도의 id 값은 부여되지 않음(NULL)
- SUBQUERY: FROM 절 이외에서 사용되는 서브쿼리만을 의미. FROM 절에 사용된 서브쿼리는 DERIVED로 표시되고 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY라고 표시함
- DEPENDENT SUBQUERY: 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우에 표시됨. 외부 쿼리가 먼저 수행된 후 내부 쿼리(서브쿼리)가 실행돼야 하므로 DEPENDENT 키워드가 없는 일반 서브쿼리보다는 처리 속도가 느릴 때가 많음
- DERIVED: MySQL 5.5 버전까지는 서브쿼리가 FROM 절에 사용된 경우 항상 DERIVED인 실행 계획을 만들지만 5.6버전부터는 옵티마이저 옵션에 따라 FROM 절에 서브쿼리를 전부 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 함. DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 임시 테이블을 생성하는 것을 의미함. DERIVED인 경우 임시 테이블을 파생 테이블이라고도 함. 5.5버전까지는 파생테이블에는 인덱스가 전혀 없어서 다른 테이블과 조인할 때 성능상 불리할 때가 많지만 5.6버전부터는 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있음. MySQL 서버는 조인에 대한 쿼리가 많이 성숙된 상태이므로 파생 테이블에 대한 최적화가 부족한 버전의 MySQL 서버를 사용 중일 경우, DERIVED 형태의 실행 계획을 조인으로 해결할 수 있게 쿼리를 바꿔주는 것이 좋음. MySQL 8.0 버전부터는 FROM 절의 서브쿼리에 대한 최적화도 많이 개선되어 불필요한 서브쿼리는 조인으로 쿼리를 재작성해서 처리하지만 옵티마이저가 처리할 수 있는 것은 한계가 있으므로 여전히 최적화된 쿼리를 작성하는 것은 중요함
- DEPENDENT DERIVED: MySQL 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 칼럼을 이용할 수 없었지만 8.0버전부터는 레터럴 조인 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 됐음. DEPENDENT DERIVED 키워드는 해당 테이블이 레터럴 조인으로 사용된 것을 의미함
- UNCACHEABLE SUBQUERY: 하나의 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아님. 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아둠. UNCACHEABLE SUBQUERY의 경우 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우를 말함. 캐시가 불가능한 경우로는 사용자 변수가 서브쿼리에 사용된 경우, NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우, UUID()나 RAND()와 같이 결괏값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우가 있음
- UNCACHEABLE UNION: UNCACHEABLE + UNION 속성이 혼합된 select_type
- MATERIALIZED: MySQL 5.6 버전부터 도입된 타입으로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용됨. DERIVED와 비슷하게 쿼리의 내용을 임시 테이블로 생성하는 것을 의미함

<br/><br/>

## table 칼럼

- MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시됨
- 별도의 테이블을 사용하지 않는 SELECT 쿼리의 경우 table 칼럼이 NULL 로 표시됨
- talbe 칼럼에 `<>`로 둘러싸인 이름은 임시 테이블을 의미하고 `<>` 안에 항상 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭함

<br/><br/>

## partitions 칼럼

- MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션들의 목록은 EXPLAIN PARTITION 명령을 이용해 확인 가능했지만 MySQL 8.0 버전부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 모두 확인할 수 있게 변경됐음
- 파티션 프루닝(Partition pruning): 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정
- 쿼리의 실행 계획을 통해서 어느 파티션을 읽는지 확인할 수 있어야 쿼리의 튜닝이 가능하므로 파티션을 참조하는 쿼리의 경우 옵티마이저가 쿼리 처리를 위해 필요한 파티션들의 목록만 모아서 실행 계획의 partitions 칼럼에 표시해줌
- 풀 테이블 스캔으로 테이블의 일부만 읽을 수 있는 이유는, MySQL을 포함한 대부분의 RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가지기 때문

<br/><br/>

## type 칼럼

- MySQL 서버가 각 테이블의 레코드를 어떤 방식(인덱스를 사용해 읽었는지, 풀 테이블 스캔이었는지 등)으로 읽었는지를 나타냄
- MySQL의 매뉴얼에서는 type 칼럼을 조인 타입으로 소개하고 MySQL에서는 하나의 테이블로부터 레코드를 읽는 작업도 조인처럼 처리함. 하지만 type 칼럼의 값은 조인과 직접 연관지어 생각하지 말고 각 테이블의 접근 방법으로 해석하면 됨
- system, const, eq_ref, ref, fulltext, ref_or_null, unique_subquery, index_subquery, range, index_merge, index, ALL 이 있음
- ALL을 제외한 나머지는 모두 인덱스를 사용한 접근 방법이고 ALL은 풀 테이블 스캔 방식을 의미함
- 하나의 SELECT 쿼리는 접근 방법 단 하나만 사용가능하고, index_merge 를 제외한 나머지 접근 방법은 하나의 인덱스만 사용함

### system

- 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고 MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법
- InnoDB에서는 ALL 또는 index로 표시될 가능성이 큼
- 실제 애플리케이션에서 사용되는 쿼리에선 거의 보이지 않음

### const

- 레코드 건수와 관계 없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있고, 반드시 1건을 반환하는 쿼리의 처리 방식
- 다른 DBMS에서는 이를 유니크 인덱스 스캔이라고도 표현함
- type 칼럼이 const인 실행 계획은 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화하여 const 로 표시됨

### eq_ref

- 여러 테이블이 조인되는 쿼리의 실행 계획에만 표시됨
- 조인에서 처음 읽은 테이블의 칼럼 값을 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때를 가리키고 두 번째 이후에 읽는 테이블의 type 칼럼에 eq_ref 가 표시됨
- 두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 유니크 인덱스는 NOT NULL이어야 하고, 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 모든 칼럼이 비교 조건에 사용돼야면 eq_ref 접근 방법이 사용될 수 있음(조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용 가능)

### ref

- 조인의 순서와 관계 없이 사용하고 프라이머리 키나 유니크 키 등의 제약 조건도 없음
- 인덱스의 종류와 관계 없이 동등 조건으로 검색할 때는 ref 접근 방법이 사용됨
- 레코드가 1건이라는 보장이 없으므로 const 나 eq_ref 보다는 빠르지 않지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법 중 하나

### fulltext

- MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법
- 전문 검색 인덱스는 통계 정보가관리되지 않고, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 함
- 쿼리에서 전문 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 사용하면 일반 인덱스의 접근 방법이 const나 eq_ref, ref가 아니면 일반적으로 MySQL은 전문 인덱스를 사용하는 조건을 선택해서 처리함
- 전문 검색은 MATCH (...) AGAINST (...) 구문을 사용해서 실행하는데 이 때 반드시 해당 테이블에 전문 검색용 인덱스가 준비돼있어야 함. 전문 인덱스가 없다면 쿼리는 오류가 발생하고 중지됨

### ref_or_null

- ref 접근 방법과 같고 NULL 비교가 추가된 형태
- 사용되어도 나쁘지 않은 접근 방법

### unique_subquery

- WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법
- 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 사용됨

### index_subquery

- IN 연산자의 특성상 IN(subquery) 또는 IN(상수 나열) 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거되어야 함
- unique_subquery는 IN(subquery)의 subquery 가 중복된 값을 만들어내지 않는다는 보장이 있어 중복 제거가 필요 없지만 IN(subquery)에서 subquery가 중복된 값을 반환할 수 있음. 이 때 서브쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 index_subquery 접근 방법이 사용됨

### range

- 인덱스 레인지 스캔 형태의 접근 방법 인덱스를 하나의 값이 아닌 범위로 검색하는 경우를 의미함
- 일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법. 얼마나 많은 레코드를 필요로하느냐에 따라 차이가 있지만 range 접근 방법도 상당히 빠름
- 인덱스 레인지 스캔에는 const, ref, range 세 가지 접근 방법을 모두 묶어서 지칭

### index_merge

- 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어내 후, 그 결과를 병합해서 처리하는 방식
- 그렇게 효율적으로 작동하는 것은 아님

### index

- 인덱스 풀 스캔을 의미함
- 풀 테이블 스캔과 비교했을 때 비교하는 레코드 건수는 같지만 인덱스가 데이터 파일 전체보다 크기가 작으므로 풀 테이블 스캔보다 빠르게 처리됨

### ALL

- 풀 테이블 스캔을 의미함
- index와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스 등과 같은 온라인 트랜잭션 처리 환경엔 적합하지 않음
- 테이블이 매우 작은 것이 아니라면 테이블에 데이터를 어느 정도 저장한 상ㅌ에서 쿼리의 성능을 확인해보고 적용하는 것이 좋음

<br/><br/>

## possible_keys 칼럼

- 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록
- possible_keys 칼럼은 특별한 경우를 제외하고는 그냥 무시해도 됨(인덱스 이름이 나와도 그 인덱스를 사용했다는 의미가 아님)

<br/><br/>

## keys 칼럼

- 최종 실행 계획에서 사용하는 인덱스를 의미
- key 칼럼에 표시되는 값이 PRIMARY인 경우에는 프라이머리 키를 사용한다는 의미이고 그 이외의 값은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 이름
- index_merge 로 접근해서 두 개 이상의 인덱스를 사용할 때는 여러 개의 인덱스가 ',' 로 구분되어 표시됨
- ALL 의 접근 방식처럼 인덱스를 전혀 사용 못할 경우 NULL 로 표시됨

<br/><br/>

## key_len 칼럼

- 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지를 알려줌
- 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값
- 다중 칼럼 인덱스뿐 아니라 단일 칼럼으로 만들어진 인덱스에서도 같은 지표를 제공함
- utf8mb4는 문자 하나가 차지하는 공간이 1바이트에서 4바이트까지 가변적인데 MySQL 서버가 utf8mb4 문자를 위해 메모리 공간을 할당해야할 때는 문자와 관계없이 고정적으로 4바이트로 계산함
- NOT NULL 이 아닌 칼럼에서는 칼럼의 값이 NULL인지 아닌지를 저장하기 위해 1바이트를 추가로 더 사용함

<br/><br/>

## ref 칼럼

- 접근 방법이 ref면 참조 조건으로 어떤 값이 제공되었는지를 보여줌. 상수값을 지정했다면 const로 표시되고, 다른 테이블의 칼럼값이면 그 테이블거과 칼럼명이 표시됨
- ref 칼럼이 func로 표시되는 경우는 참조용으로 사용되는 값을 그대로 사용한 것이 아니라 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미함
- 가능하다면 MySQL 서버가 이런 변환을 하지 않아도 되게 조인 칼럼의 타입은 일치시키는 편이 좋음

<br/><br/>

## rows 칼럼

- 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여줌
- 예상 값이라 정확하지는 않고 반환하는 레코드 수가 아닌 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미함

<br/><br/>

## filtered 칼럼

- 필터링되어 버려지는 레코드의 비율이 아닌, 필터링되고 남은 레코드의 비율
- filtered 칼럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 달라짐
- MySQL 8.0에서는 filtered 칼럼의 값을 더 정확히 예측할 수 있도록 히스토그램 기능이 도입

<br/><br/>

## Extra 칼럼

내부적인 처리 알고리즘에 대해 더 깊이 있는 내용을 보여주는 경우가 많음

- `const row not found`: const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않으면 Extra 칼럼에 이 내용이 표시됨
- `Deleting all rows`: MyISAM 스토리지 엔진과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진의 경우 표시됨. WHERE 조건절이 없는 DELETE 문장의 실행 계획에서 자주 표시되고 이 문구는 테이블의 모든 레코드를 삭제하는 핸들러 기능(API)을 한번 호출함으로써 처리됐다는 것을 의미함. 기존에는 테이블의 레코드를 삭제하기 위해 각 스토리지 엔진의 핸들러 함수를 레코드 건수만큼 호출해야 했는데 해당 처리 방식은 한 번의 핸들러 함수 호출로 아주 간단하고 빠르게 처리할 수 있음
- `Distinct`: 쿼리의 DISTINCT를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인했음을 보여줌
- `FirstMatch`: 세미 조인의 여러 최적화 중에 FirstMatch 전략이 사용됐음을 의미함. 함께 표시되는 테이블명은 기준 테이블을 의미
- `Full scan on NULL key`: `col1 IN (SELECT col2 FROM ...)` 과 같은 조건을 가진 쿼리를 실행하는 중 col1이 NULL 이면 서브쿼리에 사용된 테이블에 대해 풀 테이블 스캔을 해야만 결과를 알아낼 수 있는데, 이를 알려주는 키워드. col1이 NOT NULL 이면 이런 차선책이 사용되지 않으므로 표시될 일이 없음
- `Impossible HAVING`: HAVING 절의 조건을 만족하는 레코드가 없을 때 표시됨. 쿼리가 제대로 작성되지 못한 경우가 많으므로 쿼리를 다시 점검하는 것이 좋음
- `Impossible WHERE`: WHERE 절이 항상 FALSE가 될 수 밖에 없는 경우 표시됨
- `LooseScan`: 세미 조인 최적화 중에서 LooseScan 최적화 전략이 사용된 경우 표시됨
- `No matching min/max row`: MIN() 이나 MAX()와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때 표시됨
- `no matching row in cosnt table`: 조인에 사용된 테이블에서 const 방법으로 접근할 때 일치하는 레코드가 없다면 표시됨
- `No matching rows after partition pruning`: UPDATE 또는 DELETE 명령의 실행 계획에서 표시될 수 있는데, 해당 파티션에서 UPDATE하거나 DELETE할 대상 레코드가 없을 때 표시됨
- `No tables used`: FROM 절 자체가 없거나 FROM 절에 상수 테이블을 의미하는 DUAL(칼럼과 레코드를 각각 1개씩만 가지는 가상의 상수 테이블)이 사용될 때 표시됨
- `Not exists`: A 테이블에는 존재하지만 B 테이블에 없는 값을 조회하는 쿼리의 경우 NOT IN(subquery), NOT EXISTS 연산자를 사용한 안티-조인 형태의 조인이 사용되고 레코드 건수가 많으면 아우터조인(LEFT OUTER JOIN)을 이용하면 빠른 성능을 낼 수 있음. 이렇게 아우터 조인을 수행할 때 표시됨
- `Plan isn't ready yet`: EXPLAIIN FOR CONNECTION 명령을 실행했을 때 아직 해당 커넥션에서 쿼리의 실행 계획을 수립하지 못한 상태일 경우 표시됨
- `Range checked for each record(index map: N)`: Range checked for each record는 레코드마다 인덱스 레인지 스캔을 체크함을 의미하고 index map: N 은 사용할지 말지를 판단하는 후보 인덱스의 순번을 나타냄<br/>ex. 0x19 == 11001(2) => 인덱스: ix_nick_phone, ix_nick_gender, ix_nick_region, ix_nick_name, PRIMARY KEY => 후보 인덱스: PRIMARY KEY, ix_nick_gender, ix_nick_phone

- `Recursive`: MySQL 8.0버전 부터 CTE(Common Table Expression)를 이용해 재귀 쿼리를 작성할 수 있게 됐는데, 이렇게 CTE를 이용한 재귀 쿼리의 실행계획에 표시됨
- `Rematerialize`: MySQL 8.0버전부터 래터럴 조인 기능이 추가됐는데, 래터럴로 조인된 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 그 결과를 임시 테이블에 저장하고, 이 과정을 Rematerializing 이라고 함. 이 실행 계획에서 임시 테이블이 매번 새로 생성되는 경우 문구가 표시됨
- `Select tables optimized away`: MIN() 또는 MAX() 가 SELECT 절에 사용되거나 GROUP BY로 MIN(), MAX() 를 조회하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 사용된다면 표시됨. MyISAM 테이블에 대해서는 GROUP BY 없이 COUNT(\*)만 SELECT할 때도 이런 형태의 최적화가 적용되고, WHERE 조건절이 있는 쿼리는 최적화할 수 없음 -`Start temporary, End temporary`: 세미 조인 최적화 중에서 Duplicate Weed-out 최적화 전략이 사용된 경우 표시되고, 불필요한 중복 건을 제거하기 위해 내부 임시 테이블을 사용하는데, 조인되어 내부 임시테이블에 저장되는 테이블의 식별을 위해 조인의 첫번째 테이블엔 `Start temporary`를 조인이 끝나는 부분엔 `End temporary`문구가 표시됨
- `unique row not found`: 두 개의 테이블이 각각 유니크(프라이머리 키 포함) 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 표시됨
- `Using filesort`: ORDER BY 처리가 인덱스를 사용하지 못할 때 표시됨
- `Using index(커버링 인덱스)`: 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 표시됨. InnoDB의 모든 테이블은 클러스터링 인덱스로 구성되어 있어 모든 세컨더리 인덱스가 데이터 레코드의 주솟값으로 프라이머리 키를 가지고, 이런 특성 때문에 커버링 인덱스로 처리될 가능성이 상당히 높음
- `Using index condition`: 옵티마이저가 인덱스 컨디션 푸시 다운 최적화를 사용하면 표시됨
- `Using index for group-by`: GROUP BY 처리를 위해 MySQL 서버는 그루핑 기준 칼럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그루핑하는 형태의 고부하 작업을 필요로함. 하지만 GROUP BY 처리가 인덱스(B-Tree 인덱스에 한해서)를 이용하면 별도의 추가 정렬 작업 없이 정렬된 인덱스 칼럼을 순서대로 읽으면서 그루핑 작업만 수행함. 이처럼 GROUP BY 처리가 인덱스를 이용할 때 표시됨
  - 타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리: 인덱스를 이용해 GROUP BY를 처리할 수 있더라도 AVG(), SUM()처럼 조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 읽을 수 없음. 이런 경우는 인덱스를 쓰지만 루스 인덱스 스캔이라고 하지 않으며 Using index for group-by 메시지가 출력되지 않음
  - 루스 인덱스 스캔을 통한 GROUP BY 처리: WHERE 절에 사용하는 인덱스에 의해서도 GROUP BY 절의 인덱스 사용 여부가 영향을 받음
    - WHERE 조건절이 없는 경우: SELECT로 가져오는 칼럼과 GROUP BY 칼럼이 루스 인덱스 스캔을 사용할 수 있기만 하면됨(아니면 타이트 인덱스 스캔이나 별도의 정렬 과정으로 처리)
    - WHERE 조건절이 있지만 검색을 위해 인덱스를 사용하지 못하는 경우: 루스 인덱스 스캔을 이용할 수 없고 타이트 인덱스 스캔 과정을 통해 처리
    - WHERE 조건절이 있고 검색을 위해 인덱스를 사용하는 경우: WHERE 절의 조건과 GROUP BY 처리가 똑같은 인덱스를 공통으로 사용할 수 있을 때만 루스 인덱스 스캔을 사용할 수 있음. 둘이 다른 경우, WHERE 조건절이 인덱스를 사용하도록 옵티마이저가 실행 계획을 수립하는 경향이 있음
- `Using index for skip scan`: 옵티마이저가 인덱스 스킵 스캔 최적화를 사용하면 표시됨
- `Using join buffer(Block Nested Loop), Using join buffer(Batched Key Access), Using join buffer(hash join)`: 조인이 수행할 때 드리븐 테이블의 조인 칼럼에 적절한 인덱스가 없다면 블록 네스티드 루프 조인이나 해시 조인을 사용하게 되는데 둘을 사용하게 되면 서버가 조인 버퍼를 사용함. Using join buffer 는 조인 버퍼를 사용했음을 의미하고 괄호 안은 조인버퍼를 활용해 어떻게 처리됐는지를 보여줌
- `Using MRR`: MRR(Multi Range Read)는 여러개의 키 값을 한 번에 스토리지 엔진으로 전달하고, 스토리지 엔진은 넘겨받은 키 값들을 정렬해 최소한의 페이지 접근만으로 필요한 레코드를 읽는 최적화 방식이고, 이 MRR을 사용할 때 표시됨
- `Using sort_union(...), Using union(...), Using intersect(...)`: index_merge 접근 방법으로 실행되는 경우 두 인덱스로부터 읽은 결과를 어떻게 병합했는지 상세하게 설명하기 위해 표시됨
- `Using temporary`: 임시 테이블을 사용하면 표시됨. 단 표시되지 않지만 내부적으로는 임시테이블을 사용하는 경우도 있음
- `Using where`: MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에 표시됨
- `Zero limit`: 데이터 값이 아닌 쿼리 결과값의 메타데이터만 필요한 경우에는 쿼리의 마지막에 LIMIT 0 을 사용하면 됨. 이처럼 레코드를 읽지 않고 결괏값의 메타 데이터만 반환할 때 표시됨
