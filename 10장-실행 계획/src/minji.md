# 통계 정보

- 5.7버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립 -> 테이블 칼럼의 값들이 어떻게 분포돼 있는지에 대한 정보가 없어 정확도가 떨어지는 경우가 많았음
- 8.0부터 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됨

## 테이블 및 인덱스 통계 정보

- 통계 정보는 비용 기반 최적화에서 가장 중요함
- MySQL은 비용 기반 최적화를 사용했지만 다른 DBMS보다 통계 정보의 정확도가 높지 않고 휘발성이 강했음 -> 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완하여 사용

### MySQL 서버의 통계 정보

- 5.6버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됨
- 5.5버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고 SHOW INDEX 명령으로만 인덱스 칼럼의 분포도를 볼 수 있었음 -> 메모리에 저장되었기에 서버 재시작시, 통계 정보가 모두 사라졌음
- 5.6버전부터는 각 테이블의 통계 정보를 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리 -> 서버 재시작해도 기존 통계 정보 유지 가능
- 5.6버전에서 테이블 생성 시 `STATS_PERSISTENT` 옵션으로 테이블 단위로 영구적인 통계 정보를 보관할지 여부를 결정할 수 있음
  - 0: 5.5버전 이전 방식대로 관리. 테이블에 저장하지 않음
  - 1: innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리 (기본값)
  - 2: STATS_PERSISTENT 옵션을 설정하지 않은 것과 같음. 영구적으로 관리할지 여부를 innodb_stats_persistent 시스템 변수의 값으로 결정
- ALTER TABLE 명령으로 STAT_PERSISTENT를 1 또는 0으로 변경할 수 있음
- 테이블이 새로 오픈되거나 테이블의 레코드가 대량으로 변경되거나 ANALYZE TABLE 명령어가 실행되는 등의 이벤트가 발생하면 자동으로 통계 정보가 갱신됨
- innodb_stats_auto_recalc 시스템 변수를 OFF 로 설정하면 통계 정보 자동 갱신을 막을 수 있음
- 테이블 생성시 STATS_AUTO_RECALC 옵션을 이용해 테이블 단위로 통계 정보 자동 수집 여부를 조정할 수 있음
- 5.5버전에서 샘플링하는 테이블 블록 개수를 설정하는 innodb_stats_sample_pages 가 5.6버전부터는 innodb_stats_transient_sample_pages, innodb_stats_persistent_sample_pages 로 분리됨
  - innodb_stats_transient_sample_pages: 기본값이 8로, 자동으로 통계 정보 수집이 실행될 때 8개 페이지만 임의로 샘플링해서 분석하고 그 결과를 통계 정보로 활용함
  - innodb_stats_persistent_sample_pages: 기본값이 20으로, ANALYZE TABLE 명령이 시랳오디면 임의로 20개 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장하고 활용함
- 영구적인 통계 정보를 사용한다면 MySQL 서버 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보 수집이 가능함
- innodb_stats_persistent_sample_pages 시스템 변수에 높은 값을 설정하면 더 정확한 통계 정보 수집이 가능하지만 시간이 길어짐

<br/><br/>

## 히스토그램

- 5.7버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었음 -> 최적의 실행 계획을 수립하기엔 부족 -> 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식 사용
- 8.0버전부터 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 됨

### 히스토그램 정보 수집 및 삭제

- 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리되고, 자동으로 수집되는 것이 아니라 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리됨
- 수집된 히스토그램 정보는 시스템 딕셔너리에 함꼐 저장되고 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드함
- 8.0 버전의 히스토그램 타입
  - Singleton(싱글톤 히스토그램)
    - 칼럼값 개별로 레코드 건수를 관리하는 히스토그램. Value-Based 히스토그램 또는 도수 분포라고 불림
    - 각 버킷이 칼럼의 값과 발생 빈도 비율의 2개 값을 가짐
    - 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용됨
  - Equi-Height(높이 균형 히스토그램)
    - 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램. Height-Balanced 히스토그램이라고도 불림.
    - 각 버킷이 범위 시작 값과 마지막 값, 발생 빈도율과 각 버킷에 포함된 유니크 값의 개수 등 4개의 값을 가짐
    - 각 범위에 대해 레코드 건수 비율이 누적으로 표시됨
- information_schema.column_statistics 테이블의 HISTOGRAM 칼럼이 가진 나머지 필드
  - sampling-rate: 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율. 크기가 커질수록 정확한 히스토그램이지만 스캔에는 자원이 많이 소모됨
  - histogram-type: 히스토그램의 종류를 저장
  - number-of-buckets-specified: 히스토그램을 생성할 때 설정했던 버킷의 개수를 저장함. 기본값은 100이며 일반적으로 충분한 수치
- 히스토그램의 삭제
  - ANALYZE TABLE .. DROP HISTOGRAM ON .. 을 통해 삭제
  - 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 성능에 영향을 주지 않고 즉시 완료됨
  - 삭제하지 않고 옵티마이저가 히스토그램을 사용하지 않게 하려면 optimizer_switch 시스템 변수의 값을 변경하면 됨. 글로벌로 변경하면 서버의 모든 쿼리가 히스토그램을 사용하지 않고, condition_fanout_filter 옵션에 의해 영향받는 다른 최적화 기능들이 사용되지 않을 수 있음

### 히스토그램의 용도

- 히스토그램 정보가 없으면 옵티마이저는 균등하게 분포돼 있을 것으로 예측함
- 인덱스되지 않은 칼럼에 히스토그램이 없다면 옵티마이저는 칼럼들의 데이터 분포를 전혀 알지 못하고 실행 계획을 수립하기 때문에 좋지 않은 방향으로 조인의 드라이빙 테이블을 결정하게 됨 -> 쿼리의 성능이 10배 정도 차이를 보일 수 있음

### 히스토그램과 인덱스

- 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택함
- 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴봄(인덱스 다이브)
- 8.0 서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우 그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용함 -> 실제 검색 조건의 대상 값에 대한 샘플링이므로 항상 히스토그램보다 더 정확한 결과를 기대할 수 있음
- 인덱스 다이브는 어느 정도의 비용이 필요하고 실행 계획 수립만으로도 상당히 많은 인덱스 다이브를 실행해 비용이 그만큼 커짐

<br/><br/>

## 코스트 모델(Cost Model)

전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용

- 5.7 이전 버전까지는 작업들의 비용을 서버 소스 코드에서 상수화해서 사용했음 -> 하드웨어에 따라 달라질 수 있어 고정된 비율을 일률적으로 적용하는 것은 최적의 실행 계획 수립에 있어 방해 요소
- 5.7 버전부터는 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있기 개선. 인덱스되지 않은 칼럼의 히스토그램이나 메모리에 상주 중인 페이지의 비율 등 비용 계싼과 연관된 부분의 정보가 부족
- 8.0 버전에서는 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되어 옵티마이저의 실행 계획 수립에 사용됨
- 8.0 서버의 코스트 모델의 설정값(mysql DB에 존재)
  - server_cost: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
  - engine_cost: 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리
- server_cost 테이블과 engine_cost 테이블의 공통 칼럼
  - cost_name: 코스트 코델의 각 단위 작업
  - default_value: 각 단위 작업의 비용(기본값. 서버 소스 코드에 설정된 값)
  - cost_value: DBMS 관리자가 설정한 값(null 이면 default_value 칼럼의 비용 사용)
  - last_updated: 단위 작업 비용이 변경된 시점
  - comment: 비용에 대한 추가 설명
- engine_cost 만 갖는 칼럼
  - engine_name: 비용이 적용된 스토리지 엔진. 스토리지 엔진별로 각 단위 작업의 비용을 설정할 수 있음.
  - device_type: 디스크 타입. 8.0에선 아직 값을 활용하지 않고 0만 설정할 수 있음
- 8.0버전의 코스트 모델에서 지원하는 작업 단위: 디스크 데이터 페이지 읽기, 메모리 데이터 페이지 읽기, 디스크 임시 테이블 생성, 디스크 임시 테이블의 레코드 읽기, 인덱스 키 비교, 메모리 임시 테이블 생성, 메모리 임시 테이블의 레코드 읽기, 레코드 비교
- 코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악해야 함

<br/><br/><br/><br/>

# 실행 계획 확인

## 실행 계획 출력 포맷

- 8.0 이전 버전에서는 EXPLAIN EXTENDED 또는 EXPLAIN PARTITIONS 명령이 구분됐지만 8.0부터는 통합되어 보이도록 개선되면서 두 옵션이 제거됐음
- 8.0 버전 부터는 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON, TREE, 테이블 형태로 선택 가능함

## 쿼리의 실행 시간 확인

- EXPLAIN ANALYZE: 쿼리의 실행 계획과 단계별 소요 시간 정보를 확인할 수 있는 기능으로 8.0.18 버전부터 추가됨
- SHOW PROFILE 명령은 어떤 부분에서 시간이 많이 소요되는지는 보여주지만, 단계별로 소요된 시간 정보를 보유주진 않음
- 결과는 항상 TREE 포맷으로 출력됨
- TREE 포맷에서 들여쓰기는 호출 순서로, 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행, 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행됨
- EXPLAIN ANALYZE 명령의 결과에는 단계별로 실제 소요된 시간(actual time)과 처리한 레코드 건수(rows), 반복 횟수(loops)가 표시됨
- EXPLAIN ANALYZE 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여줌
- 쿼리의 실행 시간이 아주 많이 걸리는 쿼리면 EXPLAIN ANALYZE 명령에선 쿼리가 완료돼야 실행 계획의 결과를 확인할 수 있으므로 쿼리의 실행 계획이 나쁜 경우에는 EXPLAIN 명령으로 실행 계획만 확인해서 튜닝 후 EXPLAIN ANALYZE 명령을 실행하는 편이 좋음
